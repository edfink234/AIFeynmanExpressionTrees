<!--run locally: python3 -m http.server 8000-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive ODE &amp; PDE Dynamics Simulation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
  <!-- Explicit Plotly v2.16.1 -->
  <script src="https://cdn.plot.ly/plotly-2.16.1.min.js"></script>
  <!-- MathJax for rendering LaTeX -->
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <!-- Math.js for complex arithmetic -->
  <script src="https://unpkg.com/mathjs/lib/browser/math.js"></script>  <!-- numeric.js for linear algebra operations -->
  <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.12.1"></script>
  <script src="https://cdn.jsdelivr.net/npm/numeric@1.2.6/numeric-1.2.6.min.js"></script>
  <!-- In your HTML file, include myfunc.js after your other script tags, or import it as a module -->
  <script type="module">
    window.loadedCPPFunctions = false;
    // Import the module creation function. Adjust the path as needed.
    // This below ⬇️ worked!
    // emcc myfunc.c -Os -s WASM=1 -s EXPORT_ES6=1 -s MODULARIZE=1 -s EXPORT_NAME="createModule" -s EXPORTED_FUNCTIONS='["_sech"]' -s EXPORTED_RUNTIME_METHODS="['ccall']" -o myfunc.js
    import createModule from './myfunc.js';
    window.createModule = createModule;
    // When you call createModule, it returns a Promise that resolves once the module is initialized.
    createModule().then((Module) => {
      // Now you can call your C function (f) from JavaScript.
      const result = Module.ccall('sech',      // C function name
                                   'number', // return type
                                   ['number'], // argument type(s)
                                   [Math.PI / 4]); // arguments
      console.log("Result of sech(Math.PI/4) =", result);
      const sech = Module.cwrap('sech', 'number', ['number']);
      window.sech = sech; //put sech in global scope
      const computeEigenspectrumCpp = Module.cwrap('computeEigenspectrum', 'number', ["number", "number"]);
      window.computeEigenspectrumCpp = computeEigenspectrumCpp;
      window.loadedCPPFunctions = true;
      // You can now use this function in your performance-critical code.
      // For example, if you want to call f(x) many times in your simulation, wrap this call.
    }).catch(err => {
      console.error("Error initializing module", err);
    });
  </script>

  
</head>
<body>
<div class="container-fluid">
  <h1 class="text-center">ODE &amp; PDE Dynamics Simulation</h1>

  <!-- Parameter Input Form -->
  <form id="paramsForm">
    <div class="row">
      <!-- Shared parameters -->
      <div class="col-md-4">
        <h3>Shared Parameters</h3>
        <div class="form-group">
          <label for="x0">Initial Position \( x_0 \)</label>
          <input type="number" step="any" class="form-control" id="x0" value="0">
        </div>
        <div class="form-group">
          <label for="v0">Initial Velocity \( v_0 \)</label>
          <input type="number" step="any" class="form-control" id="v0" value="0">
        </div>
        <div class="form-group">
          <label for="T">Total Time \( T \)</label>
          <input type="number" step="any" class="form-control" id="T" value="100">
        </div>
        <div class="form-group">
          <label for="dt">Time Step \( \Delta t \)</label>
          <input type="number" step="any" class="form-control" id="dt" value="0.05">
        </div>
        <div class="form-group">
          <label for="stepsPerUpdate">How often to update the plot (milli-seconds)</label>
          <input type="number" step="1" min="1" class="form-control" id="stepsPerUpdate" value="1">
        </div>
      </div>
      <!-- ODE parameters -->
      <div class="col-md-4">
        <h3>ODE Parameters</h3>
        <div class="form-group">
          <label for="m">Mass \( m \)</label>
          <input type="number" step="any" class="form-control" id="m" value="1">
        </div>
        <div class="form-group">
          <label for="Omega">\( \Omega \)</label>
          <input type="number" step="any" class="form-control" id="Omega" value="0.2">
        </div>
        <div class="form-group">
          <label for="A">Amplitude \( A \)</label>
          <input type="number" step="any" class="form-control" id="A" value="1">
        </div>
        <div class="form-group">
          <label for="b">Width Factor \( b \)</label>
          <input type="number" step="any" class="form-control" id="b" value="1">
        </div>
      </div>
      <!-- PDE parameters -->
      <div class="col-md-4">
        <h3>PDE Parameters</h3>
        <div class="form-group">
          <label for="A_sol">Soliton Amplitude \( A_{sol} \)</label>
          <input type="number" step="any" class="form-control" id="A_sol" value="1">
        </div>
        <div class="form-group">
          <label for="omega">Chemical Potential \( \omega \)</label>
          <input type="number" step="any" class="form-control" id="omega" value="0.5">
        </div>
        <div class="form-group">
          <label for="Omega_pde">\( \Omega_{pde} \)</label>
          <input type="number" step="any" class="form-control" id="Omega_pde" value="0.2">
        </div>
        <div class="form-group">
          <label for="A_pde">\( A_{pde} \)</label>
          <input type="number" step="any" class="form-control" id="A_pde" value="1">
        </div>
        <div class="form-group">
          <label for="b_pde">\( b_{pde} \)</label>
          <input type="number" step="any" class="form-control" id="b_pde" value="1">
        </div>
      </div>
    </div>
    <!-- Spatial parameters for the PDE -->
    <div class="row">
      <div class="col-md-4">
        <h3>Spatial Parameters (PDE)</h3>
        <div class="form-group">
          <label for="dx">Spatial Step \( \Delta x \)</label>
          <input type="number" step="any" class="form-control" id="dx" value="0.38">
        </div>
        <div class="form-group">
          <label for="x_min">\( x_{min} \)</label>
          <input type="number" step="any" class="form-control" id="x_min" value="-2">
        </div>
        <div class="form-group">
          <label for="x_max">\( x_{max} \)</label>
          <input type="number" step="any" class="form-control" id="x_max" value="2">
        </div>
      </div>
    </div>
  </form>
  
  <!-- Simulation Control Buttons -->
  <div class="my-3">
    <button id="startBtn" class="btn btn-success">Start</button>
    <button id="stopBtn" class="btn btn-danger">Stop</button>
    <button id="computeSpectrumBtn" class="btn btn-primary">Compute Steady-State Spectrum</button>
    <label class="ml-2">
      <input type="checkbox" id="loopToggle"> Auto-loop
    </label>
    <label class="ml-2">
      <input type="checkbox" id="applyNewtonToggle" unchecked> Apply Newton
    </label>
    <label class="ml-2">
      <input type="checkbox" id="applyAlertToggle" unchecked> Alert Newton Progress
    </label>
  </div>
  
  <div class="row">
      <div class = "col" id="newtonProgressContainer" style="display:none; margin-bottom: 10px;">
        <label>Newton Refinement Progress:</label>
        <progress id="newtonProgressBar" value={0} max="100"></progress>
      </div>
  </div>

  <!-- Simulation Plots: Two columns side-by-side -->
  <div class="row">
    <div class="col">
      <div id="odePlot"></div>
    </div>
    <div class="col">
      <div id="pdePlot"></div>
    </div>
  </div>
  
    <!-- Eigen Mode Decomposition Plots: Four columns side-by-side -->
    <div id = "stabilityPlots" style="display:none; margin-bottom: 10px;">
        <div class="row">
            <div class="col">
                <div id="eigenvaluePlot" style="height:300px; width:100%;"></div>
            </div>
            <div class="col">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <button id="prevModeBtn" class="btn btn-secondary">Previous Mode</button>
                    <span id="modeCounter">Mode: 0</span>
                    <button id="nextModeBtn" class="btn btn-secondary">Next Mode</button>
                </div>
                <div id="eigenmodePlot" style="height:300px; width:100%;">
                </div>
            </div>
        </div>
        <div class = "row">
            <div class = "col" style="text-align:center">
                <button id="closeStab" class="btn btn-danger" onclick = "document.getElementById('stabilityPlots').style.display='none';">Close</button>
            </div>
        </div>
    </div>
</div>
    
<!-- Simulation JavaScript -->
<script>
    // Global simulation variables
    const A = new mlMatrix.Matrix([
        [1, 2],
        [3, 4]
      ]); // Should log the ML namespace
    console.log("A =",A);
    let simInterval = null;
    let plotInterval = null;
    let currentTime = 0;
    let simulationRunning = false;
    let tol = 1e-10; //For Newton refinement
    let progress = 0; //For Newton refinement
    let V;
    // Global variable to track which eigenmode to display.
    let currentEigenMode = 0;
    let spectrum;

    // This function updates the eigenmode plot for the mode at index currentEigenMode.
    function updateEigenmodePlot(params) {
      // Ensure we have at least one eigenmode:
      if (!spectrum || !spectrum.eigenmodes || spectrum.eigenmodes.length === 0) return;
      console.log("currentEigenMode =",currentEigenMode);
      // Get the current eigenmode:
      let mode = spectrum.eigenmodes[currentEigenMode];
      console.log("mode "+currentEigenMode+" = ",mode);
      // Create a grid for x:
      let xgrid = linspace(params.x_min, params.x_max, params.N);
      console.log("x_grid.length=",xgrid.length,"mode.length=",mode.length);
      
      // Set up three traces:
      let modeRealTrace = {
        x: xgrid,
        y: mode.map(z => z.re),
        mode: 'lines',
        name: 'Real part'
      };
      let modeImagTrace = {
        x: xgrid,
        y: mode.map(z => z.im),
        mode: 'lines',
        name: 'Imaginary part'
      };
      let modeNormTrace = {
        x: xgrid,
        y: mode.map(z => math.pow(math.abs(z), 2)),
        mode: 'lines',
        name: '|Mode|²'
      };
      
      let modeLayout = {
        title: 'Eigenmode Details',
        xaxis: { title: 'x' },
        yaxis: { title: 'Value' },
        annotations: [{
          xref: 'paper', yref: 'paper', x: 0.05, y: 0.95,
          text: `Mode: ${currentEigenMode}`, showarrow: false, font: { size: 16 }
        }]
      };
      
      Plotly.newPlot('eigenmodePlot', [modeRealTrace, modeImagTrace, modeNormTrace], modeLayout);
      
      // Update the counter
      document.getElementById("modeCounter").textContent = `Mode: ${currentEigenMode}`;
    }

    // Setup the event listeners for the buttons
    document.getElementById("prevModeBtn").addEventListener("click", function() {
      // Wrap around if needed:
      if (spectrum && spectrum.eigenmodes) {
        currentEigenMode = (currentEigenMode - 1 + spectrum.eigenmodes.length) % spectrum.eigenmodes.length;
        updateEigenmodePlot(getParameters());
      }
    });

    document.getElementById("nextModeBtn").addEventListener("click", function() {
      if (spectrum && spectrum.eigenmodes) {
        currentEigenMode = (currentEigenMode + 1) % spectrum.eigenmodes.length;
        updateEigenmodePlot(getParameters());
      }
    });

    
    const interval = setInterval(() => {
        document.getElementById("newtonProgressBar").setAttribute("value", progress);
    }, 5)

    // ODE state (position and velocity)
    let odeState = {x: 0, v: 0};

    // PDE variables
    let pdeGrid = []; // spatial grid for PDE
    let pdePotential = []; // PDE Potential
    let u = [];       // array of math.complex objects for u(x,t)
    let N = 0;        // number of spatial grid points
    let k = [];       // wavenumber array for FFT
    let U_pde = [];
    // Retrieve parameters from input fields
    function getParameters() {
      return {
        // Shared
        x0: parseFloat(document.getElementById("x0").value),
        v0: parseFloat(document.getElementById("v0").value),
        T: parseFloat(document.getElementById("T").value),
        dt: parseFloat(document.getElementById("dt").value),
        stepsPerUpdate: parseInt(document.getElementById("stepsPerUpdate").value),
        // ODE
        m: parseFloat(document.getElementById("m").value),
        Omega: parseFloat(document.getElementById("Omega").value),
        A: parseFloat(document.getElementById("A").value),
        b: parseFloat(document.getElementById("b").value),
        // PDE
        A_sol: parseFloat(document.getElementById("A_sol").value),
        omega: parseFloat(document.getElementById("omega").value),
        Omega_pde: parseFloat(document.getElementById("Omega_pde").value),
        A_pde: parseFloat(document.getElementById("A_pde").value),
        b_pde: parseFloat(document.getElementById("b_pde").value),
        // Spatial parameters (PDE)
        dx: parseFloat(document.getElementById("dx").value),
        x_min: parseFloat(document.getElementById("x_min").value),
        x_max: parseFloat(document.getElementById("x_max").value),
        N: Math.floor( ( parseFloat(document.getElementById("x_max").value) - parseFloat(document.getElementById("x_min").value) ) / parseFloat(document.getElementById("dx").value) ),
        g: -1,
        wfreq: parseFloat(document.getElementById("omega").value)
      };
    }

    // Utility: hyperbolic secant function
    function linspace(a, b, n) {
      let arr = [];
      let step = (b - a) / (n - 1);
      for(let i = 0; i < n; i++){
        arr.push(a + step * i);
      }
      return arr;
    }

    // ---------------------- ODE Simulation ----------------------
    function odeRHS(x, v, params) {
      let acceleration = (-params.Omega * params.Omega * x + 2 * params.A * params.b * Math.pow(sech(params.b * x), 2) * Math.tanh(params.b * x)) / params.m;
      return {dx: v, dv: acceleration};
    }

    function rk4Step(x, v, dt, params) {
      let k1 = odeRHS(x, v, params);
      let k2 = odeRHS(x + 0.5 * dt * k1.dx, v + 0.5 * dt * k1.dv, params);
      let k3 = odeRHS(x + 0.5 * dt * k2.dx, v + 0.5 * dt * k2.dv, params);
      let k4 = odeRHS(x + dt * k3.dx, v + dt * k3.dv, params);
      let x_new = x + (dt/6) * (k1.dx + 2*k2.dx + 2*k3.dx + k4.dx);
      let v_new = v + (dt/6) * (k1.dv + 2*k2.dv + 2*k3.dv + k4.dv);
      return {x: x_new, v: v_new};
    }

    // ----------------------- PDE Simulation using RK4 -----------------------
    // We discretize the PDE: i u_t = -0.5 u_xx - |u|^2 u + V(x) u
    // The right-hand side is: u_t = i*(0.5*u_xx + |u|^2*u - V(x)*u)
    // using finite differences (with periodic BCs) for u_xx.

    // Trapezoidal integration helper.
    function trapz(y, x) {
      let sum = 0;
      for (let i = 0; i < y.length - 1; i++) {
        sum += 0.5 * (y[i] + y[i+1]) * (x[i+1] - x[i]);
      }
      return sum;
    }
    
    //////////////////////////////////
    // SolveOde (main function)
    //
    // input:
    //   func: ordinary differential equation (ODE) you want to specify
    //   solver: rkf45, dopri5, or dop853
    //   param: Parameters for ODE
    //   start:
    //   end:
    //   h: step
    //   amt: initial values (number[])
    //
    // output: TypeResult
    //   [
    //      number[],    // x
    //      number[][]   // vector of y
    //   ]
    //////////////////////////////////
    function SolveOde(func, solver, param, start, end, h, amt) {
        var n = Math.floor((end - start) / h);
        var t = start;
        var x = Array(n + 1);
        var y = Array(n + 1);
        for (var i = 0; i < n - 1; i++) {
            x[i] = t;
            y[i] = amt;
            amt = solver(func, param, amt, t, h, false)[0];
            t += h;
        }
        // last - 1
        x[n - 1] = t;
        y[n - 1] = amt;
        // last
        amt = solver(func, param, amt, t, end - t, false)[0];
        x[n] = end;
        y[n] = amt;
        return [x, y];
    }
    
    // Dormand-Prince method order 8
    // Reference
    // dop853.f
    // http://www.unige.ch/~hairer/software.html
    function dop853(func, param, x, t, h, adaptive) {
        function calc(param, x, t, h, adaptive) {
            var k1 = func(x, param, t);
            var k2 = func(adds(x, multiple(5.26001519587677318785587544488e-2 * h, k1)), param, t + 0.526001519587677318785587544488e-1 * h);
            var k3 = func(adds(x, multiple(1.97250569845378994544595329183e-2 * h, k1), multiple(5.91751709536136983633785987549e-2 * h, k2)), param, t + 0.789002279381515978178381316732e-1 * h);
            var k4 = func(adds(x, multiple(2.95875854768068491816892993775e-2 * h, k1), multiple(8.87627564304205475450678981324e-2 * h, k3)), param, t + 0.118350341907227396726757197510 * h);
            var k5 = func(adds(x, multiple(2.41365134159266685502369798665e-1 * h, k1), multiple(-8.84549479328286085344864962717e-1 * h, k3), multiple(9.24834003261792003115737966543e-1 * h, k4)), param, t + 0.281649658092772603273242802490 * h);
            var k6 = func(adds(x, multiple(3.7037037037037037037037037037e-2 * h, k1), multiple(1.70828608729473871279604482173e-1 * h, k4), multiple(1.25467687566822425016691814123e-1 * h, k5)), param, t + 0.333333333333333333333333333333 * h);
            var k7 = func(adds(x, multiple(3.7109375e-2 * h, k1), multiple(1.70252211019544039314978060272e-1 * h, k4), multiple(6.02165389804559606850219397283e-2 * h, k5), multiple(-1.7578125e-2 * h, k6)), param, t + 0.25 * h);
            var k8 = func(adds(x, multiple(3.70920001185047927108779319836e-2 * h, k1), multiple(1.70383925712239993810214054705e-1 * h, k4), multiple(1.07262030446373284651809199168e-1 * h, k5), multiple(-1.53194377486244017527936158236e-2 * h, k6), multiple(8.27378916381402288758473766002e-3 * h, k7)), param, t + 0.307692307692307692307692307692 * h);
            var k9 = func(adds(x, multiple(6.24110958716075717114429577812e-1 * h, k1), multiple(-3.36089262944694129406857109825 * h, k4), multiple(-8.68219346841726006818189891453e-1 * h, k5), multiple(2.75920996994467083049415600797e1 * h, k6), multiple(2.01540675504778934086186788979e1 * h, k7), multiple(-4.34898841810699588477366255144e1 * h, k8)), param, t + 0.651282051282051282051282051282 * h);
            var k10 = func(adds(x, multiple(4.77662536438264365890433908527e-1 * h, k1), multiple(-2.48811461997166764192642586468 * h, k4), multiple(-5.90290826836842996371446475743e-1 * h, k5), multiple(2.12300514481811942347288949897e1 * h, k6), multiple(1.52792336328824235832596922938e1 * h, k7), multiple(-3.32882109689848629194453265587e1 * h, k8), multiple(-2.03312017085086261358222928593e-2 * h, k9)), param, t + 0.6 * h);
            var k11 = func(adds(x, multiple(-9.3714243008598732571704021658e-1 * h, k1), multiple(5.18637242884406370830023853209 * h, k4), multiple(1.09143734899672957818500254654 * h, k5), multiple(-8.14978701074692612513997267357 * h, k6), multiple(-1.85200656599969598641566180701e1 * h, k7), multiple(2.27394870993505042818970056734e1 * h, k8), multiple(2.49360555267965238987089396762 * h, k9), multiple(-3.0467644718982195003823669022 * h, k10)), param, t + 0.857142857142857142857142857142 * h);
            var k12 = func(adds(x, multiple(2.27331014751653820792359768449 * h, k1), multiple(-1.05344954667372501984066689879e1 * h, k4), multiple(-2.00087205822486249909675718444 * h, k5), multiple(-1.79589318631187989172765950534e1 * h, k6), multiple(2.79488845294199600508499808837e1 * h, k7), multiple(-2.85899827713502369474065508674 * h, k8), multiple(-8.87285693353062954433549289258 * h, k9), multiple(1.23605671757943030647266201528e1 * h, k10), multiple(6.43392746015763530355970484046e-1 * h, k11)), param, t + h);
            var x_ = adds(x, multiple(5.42937341165687622380535766363e-2 * h, k1), multiple(4.45031289275240888144113950566 * h, k6), multiple(1.89151789931450038304281599044 * h, k7), multiple(-5.8012039600105847814672114227 * h, k8), multiple(3.1116436695781989440891606237e-1 * h, k9), multiple(-1.52160949662516078556178806805e-1 * h, k10), multiple(2.01365400804030348374776537501e-1 * h, k11), multiple(4.47106157277725905176885569043e-2 * h, k12));
            if (!adaptive) {
                return [x_, null];
            }
            var delta5 = adds(multiple(0.1312004499419488073250102996e-1, k1), multiple(-0.1225156446376204440720569753e+1, k6), multiple(-0.4957589496572501915214079952, k7), multiple(0.1664377182454986536961530415e+1, k8), multiple(-0.3503288487499736816886487290, k9), multiple(0.3341791187130174790297318841, k10), multiple(0.8192320648511571246570742613e-1, k11), multiple(-0.2235530786388629525884427845e-1, k12));
            var delta3 = adds(multiple(-0.189800754072407617468755659980, k1), multiple(4.45031289275240888144113950566, k6), multiple(1.89151789931450038304281599044, k7), multiple(-5.8012039600105847814672114227, k8), multiple(-0.422682321323791962932445679177, k9), multiple(-1.52160949662516078556178806805e-1, k10), multiple(2.01365400804030348374776537501e-1, k11), multiple(0.0226517921983608258118062039631, k12));
            var err5 = 0;
            var err3 = 0;
            for (var i = 0; i < x.length; i++) {
                var sc = adaptive.atol[i] +
                    Math.max(Math.abs(x[i]), Math.abs(x_[i])) * adaptive.rtol[i];
                err5 += Math.pow((delta5[i] / sc), 2);
                err3 += Math.pow((delta3[i] / sc), 2);
            }
            var denominator = (err5 !== 0 || err3 !== 0) ? err5 + 0.01 * err3 : 1;
            var err = Math.abs(h) * err5 * Math.sqrt(1 / (x.length * denominator));
            return [x_, err];
        }
        ; // end of calc
        var options = (adaptive === false) ? undefined : (function () {
            var atol = [];
            var rtol = [];
            var userOptions = (typeof adaptive === "boolean") ? undefined : adaptive;
            for (var i = 0; i < x.length; i++) {
                var a = userOptions ?
                    (Array.isArray(userOptions.atol) ? userOptions.atol[i] :
                        userOptions.atol) : undefined;
                var r = userOptions ?
                    (Array.isArray(userOptions.rtol) ? userOptions.rtol[i] :
                        userOptions.rtol) : undefined;
                atol.push(((a === 0 && r === 0) || typeof a === "undefined" || a < 0) ?
                    1e-12 : a);
                rtol.push((typeof r === "undefined" || r < 0) ? 1e-6 : r);
            }
            return {
                atol: atol,
                rtol: rtol,
                maxiter: userOptions === null || userOptions === void 0 ? void 0 : userOptions.maxiter,
                fac: userOptions === null || userOptions === void 0 ? void 0 : userOptions.fac,
                facmax: userOptions === null || userOptions === void 0 ? void 0 : userOptions.facmax,
                facmin: userOptions === null || userOptions === void 0 ? void 0 : userOptions.facmin,
            };
        })();
        return _ode(calc, param, x, t, h, options);
    }
    
    function zip() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return Array.from(Array(Math.min.apply(Math, args.map(function (v) { return v.length; }))), function (_, i) {
            return args.map(function (v) { return v[i]; });
        });
    }
    function adds() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return zip.apply(void 0, args).map(function (v) {
            return v.reduce(function (a, b) { return a + b; });
        });
    }
    function multiple(a, b) {
        return b.map(function (v) {
            return a * v;
        });
    }
    //////////////////////////////////
    // Reference
    // Ernst Hairer, Gerhard Wanner, Syvert P. Nørsett.
    // Solving Ordinary Differential Equations I: Nonstiff Problems.
    // Springer.
    //////////////////////////////////
    function _ode(func, param, x, t, h, adaptive) {
        var _a;
        if (!adaptive) {
            var x_ = func(param, x, t, h)[0];
            return [x_, t + h, h];
        }
        var maxiter = (_a = adaptive.maxiter) !== null && _a !== void 0 ? _a : 100;
        var facmax = 5;
        if (adaptive.facmax && adaptive.facmax > 0) {
            facmax = adaptive.facmax;
        }
        var facmin = 0.1;
        if (adaptive.facmin && adaptive.facmin > 0) {
            facmin = adaptive.facmin;
        }
        var fac = 0.9;
        if (adaptive.fac && adaptive.fac > 0) {
            fac = adaptive.fac;
        }
        var h_ = h;
        var i = 0;
        while (i++ < maxiter) {
            var _b = func(param, x, t, h_, {
                atol: adaptive.atol,
                rtol: adaptive.rtol
            }), x_ = _b[0], err = _b[1];
            if (!err) {
                break;
            }
            var t_ = t + h_;
            h_ *= Math.min(facmax, Math.max(facmin, fac * (Math.pow((1 / err), 0.2))));
            if (err < 1) {
                return [x_, t_, h_];
            }
        }
        throw new Error();
    }
    
    // This function computes the derivative of U (a real 2N‐vector)
    // at time t. It uses finite differences with periodic BCs.
    function pde_rhs_dop853(U, params, t) {
      // Let N be half the length of U.
      N = U.length / 2;
      let dx = params.dx;
      // Reconstruct complex u from U (first N entries are real, next N are imag)
      let u_complex = new Array(N);
      for (let i = 0; i < N; i++) {
        u_complex[i] = math.complex(U[i], U[i + N]);
      }
      // Compute u_xx with periodic BCs.
      let u_xx = new Array(N);
      for (let i = 0; i < N; i++) {
        let ip = (i + 1) % N;
        let im = (i - 1 + N) % N;
        u_xx[i] = math.divide(
          math.add(math.subtract(u_complex[ip], math.multiply(2, u_complex[i])), u_complex[im]),
          dx * dx
        );
      }
      // Compute potential V(x) on our grid.
      V = pdeGrid.map(x => 0.5 * params.Omega_pde * params.Omega_pde * x * x +
                            params.A_pde * Math.pow(sech(params.b_pde * x), 2));
      // Compute rhs for each grid point.
      let rhs = new Array(N);
      for (let i = 0; i < N; i++) {
        // nonlinear term: |u|^2 * u
        let nonlinear = math.multiply(Math.pow(math.abs(u_complex[i]), 2), u_complex[i]);
        // inside = 0.5*u_xx + nonlinear - V(x)*u
        let inside = math.subtract(math.add(math.multiply(0.5, u_xx[i]), nonlinear),
                                   math.multiply(V[i], u_complex[i]));
        // Multiply by i (i.e., rotate by 90° in the complex plane)
        rhs[i] = math.multiply(math.complex(0, 1), inside);
      }
      // Return Udot as the concatenation of real and imag parts.
      let rhsReal = rhs.map(z => z.re);
      let rhsImag = rhs.map(z => z.im);
      return rhsReal.concat(rhsImag);
    }
    
    // Assume that SolveOde and dop853 are defined (or imported) per your attached code.
    function pdeStep_dop853(params) {
      // Here, U_pde is a global variable holding the current 2N-vector,
      // where N is the number of spatial points in pdeGrid.
      // Integrate the PDE from time currentTime to currentTime+dt.
      let startT = currentTime;
      let endT = currentTime + params.dt;
      let result = SolveOde(pde_rhs_dop853, dop853, params, startT, endT, params.dt, U_pde);
      // result[1] is the list of solution vectors; take the last one.
      U_pde = result[1][result[1].length - 1];
      // Reconstruct u (complex) from U_pde.
      N = U_pde.length / 2;
      u = new Array(N);
      for (let i = 0; i < N; i++) {
        u[i] = math.complex(U_pde[i], U_pde[i+N]);
      }
      currentTime = endT;
    }

    // Compute the PDE RHS for a given u array.
    function pde_rhs(u, params) {
      let rhs = new Array(N);
      let dx = params.dx;
      // Compute potential V(x) at grid points:
      V = pdeGrid.map(x => 0.5 * params.Omega_pde * params.Omega_pde * x * x + params.A_pde * Math.pow(sech(params.b_pde * x), 2));
      for (let i = 0; i < N; i++) {
        let ip = (i + 1) % N;
        let im = (i - 1 + N) % N;
        // Second derivative using central difference (periodic BC):
        let u_xx = math.divide(math.add(math.subtract(u[ip], math.multiply(2, u[i])), u[im]), dx * dx);
        let nonlinear = math.multiply(Math.pow(math.abs(u[i]), 2), u[i]);
        let potTerm = math.multiply(V[i], u[i]);
        let inside = math.subtract(math.add(math.multiply(0.5, u_xx), nonlinear), potTerm);
        // Multiply by i:
        rhs[i] = math.multiply(math.complex(0, 1), inside);
      }
      return rhs;
    }

    // RK4 step for PDE: returns new u array.
    function pdeRK4Step(u, dt, params) {
      let k1 = pde_rhs(u, params);
      let u2 = new Array(N);
      for (let i = 0; i < N; i++) {
        u2[i] = math.add(u[i], math.multiply(dt/2, k1[i]));
      }
      let k2 = pde_rhs(u2, params);
      let u3 = new Array(N);
      for (let i = 0; i < N; i++) {
        u3[i] = math.add(u[i], math.multiply(dt/2, k2[i]));
      }
      let k3 = pde_rhs(u3, params);
      let u4 = new Array(N);
      for (let i = 0; i < N; i++) {
        u4[i] = math.add(u[i], math.multiply(dt, k3[i]));
      }
      let k4 = pde_rhs(u4, params);
      let newU = new Array(N);
      for (let i = 0; i < N; i++) {
        newU[i] = math.add(u[i],
          math.multiply(dt/6,
            math.add(k1[i],
              math.multiply(2, k2[i]),
              math.multiply(2, k3[i]),
              k4[i]
            )
          )
        );
      }
      return newU;
    }

    // The PDE step simply applies one RK4 time step.
    function pdeStep(params) {
      //console.log("u=",u);
      u = pdeRK4Step(u, params.dt, params);
    }

    // ----------------------- PDE Initialization -----------------------
    // Initialize the spatial grid and initial guess for u.
    // The initial ansatz is: u0(x) = A_sol * sech(A_sol*(x - x0)) * exp(i*v0*x)
    // (Optionally, one could refine this guess using Newton's method; here we assume the ansatz is acceptable.)
    function initPDE(params) {
        let {x_min, x_max, dx, x0, A_sol, v0} = params;
        N = Math.floor((x_max - x_min) / dx);
        pdeGrid = new Array(N);
        let applyNewtonToggleChecked = document.getElementById("applyNewtonToggle").checked;
        // Set initial condition for u:
        u = new Array(N);
        for (let i = 0; i < N; i++) {
            pdeGrid[i] = x_min + i * dx;
            let x = pdeGrid[i];
            let amplitude = params.A_sol * sech(params.A_sol * (x - x0));
            let phase = v0 * x;
            if (applyNewtonToggleChecked)
            {
                u[i] = math.complex(amplitude, 0);
            }
            else
            {
                u[i] = math.complex(amplitude * Math.cos(phase), amplitude * Math.sin(phase));
            }
        }
        if (document.getElementById("applyNewtonToggle").checked)
        {
            alert("Applying Newton now, please wait.");
            [u, D2, x] = refineNewton(u, params);
            //tack on velocity afterwards
            for (let i = 0; i < N; i++)
            {
                let phase = v0 * x[i];
                u[i] = math.complex(u[i].re*Math.cos(phase), u[i].im* Math.sin(phase));
            }
        }
        U_pde = u.map(z => z.re).concat(u.map(z => z.im));
        //console.log("U_pde=",U_pde);
    }
    
    // For PDE refinement, we define a local potential function using PDE parameters.
    function potentialForRefinement(x, params) {
      return 0.5 * params.Omega_pde * params.Omega_pde * x * x + params.A_pde * Math.pow(sech(params.b_pde * x), 2);
    }
    
    // Helper functions for matrix concatenation:
    function hconcat(mat1, mat2) {
      if (mat1.length !== mat2.length) { throw "Matrices must have the same number of rows"; }
      let res = [];
      for (let i = 0; i < mat1.length; i++) {
        res.push(mat1[i].concat(mat2[i]));
      }
      return res;
    }
    function vconcat(mat1, mat2) {
      return mat1.concat(mat2);
    }
    
    // --------------------------------------------------------------------
    // NEWTON REFINEMENT FUNCTION
    // It builds a local grid, computes the initial guess u0 = A_sol*sech(A_sol*(x - xStart))*exp(1j*c*x)
    // and then iterates a Newton method (with a full Jacobian using a finite-difference Laplacian matrix)
    // to refine U, which is a concatenation of real and imaginary parts.
    function refineNewtonHelper(u0, params, lr = 1) {
      // We'll override the initial u with our own ansatz on the refinement grid.
      let g = params.g;  // focusing NLS
      let L = params.x_min, R = params.x_max;
      let dx = params.dx;

      let x = new Array(N);
      for (let i = 0; i < N; i++)
      {
          x[i] = params.x_min + i * dx;
      }

      // Adjust for periodic BCs: remove last point.
      let point5_over_dx_squared = 0.5/(dx*dx);
      let one_over_six = 1/6;
      
      // Use c = 0 for the refinement since it's a steady-state problem
      let A_sol = params.A_sol
      let c = 0;
      // xStart from webpage: use params.x0.
      let xStart = params.x0;
      
      // U: concatenation of real and imaginary parts; will be an array of length 2N.
      let U = new Array(2 * N);
      for (let i = 0; i < N; i++) {
        //console.log(u0[i]);
        U[i] = u0[i].re;
        U[i + N] = u0[i].im;
      }
      
      // Compute potential V on the refinement grid.
      V = new Array(N);
      for (let i = 0; i < N; i++){
          V[i] = potentialForRefinement(x[i], params);
      }
      //console.log("V =",V);
      let w_sol = params.omega;
      
      let err = Infinity;
      let max_iter = 100;
      let iter = 0;
      
      // Build the discrete Laplacian matrix D2 (NxN) with periodic boundaries.
      let D2 = numeric.rep([N, N], 0);
      for (let i = 0; i < N; i++){
        D2[i][i] = -2;
        D2[i][(i+1)%N] = 1;
        D2[i][(i-1+N)%N] = 1;
      }
      D2 = numeric.mul(D2, 1/(dx*dx));
      //console.log("D2 =", D2);
      // Indices: first N entries for real parts, next N for imaginary parts.
      let indR_start = 0, indR_end = N;
      let indI_start = N, indI_end = 2*N;
      
      // Newton iteration.
      let U2 = new Array(N);
      let common_term = new Array(N);
      let Fr = new Array(N), Fi = new Array(N);
      let diagJ11 = new Array(N), diagJ22 = new Array(N), diagJ12 = new Array(N);

      while(err > tol && iter < max_iter) {
          /*setTimeout(() => {window.document.getElementById("newtonProgressBar").outerHTML =
          String.raw`
          <div id="newtonProgressBar" class="progress-bar" role="progressbar" style="width: ${progress}%;" aria-valuenow="${progress}" aria-valuemin="0" aria-valuemax="100"></div>
          `}, 0);*/
        // Extract Ur and Ui from U.
        let Ur = U.slice(indR_start, indR_end);
        let Ui = U.slice(indI_start, indI_end);
        //console.log("Ur =", Ur);
        //console.log("Ui =", Ui);

        // Compute modulus squared U2 = Ur^2 + Ui^2, elementwise.
        for (let i = 0; i < N; i++){
          U2.push(Ur[i]*Ur[i] + Ui[i]*Ui[i]);
        }
        //console.log("U2 =",U2);
        // Compute common_term = g*U2 + V + w_sol.
        for (let i = 0; i < N; i++){
            //console.log(`g=${g}, U2[${i}]=${U2[i]}, V[${i}]=${V[i]}, w_sol = ${w_sol}`);
            let r = Ur[i], im = Ui[i];
            U2[i] = r * r + im * im;
            common_term[i] = g * U2[i] + V[i] + w_sol;
        }
        //console.log("common_term =",common_term);
        // Compute residual F:
        // F_r = -0.5 * (D2 * Ur) + common_term .* Ur.
        // F_i = -0.5 * (D2 * Ui) + common_term .* Ui.
        let D2Ur = numeric.dot(D2, Ur);
        let D2Ui = numeric.dot(D2, Ui);
        //console.log("D2Ur =",D2Ur);
        //console.log("D2Ui =",D2Ui);
        for (let i = 0; i < N; i++) {
          Fr[i] = -0.5 * D2Ur[i] + common_term[i] * Ur[i];
          Fi[i] = -0.5 * D2Ui[i] + common_term[i] * Ui[i];
        }
        //console.log("Fr =",Fr);
        //console.log("Fi =",Fi);
        // F is concatenation of Fr and Fi.
        let F_vec = Fr.concat(Fi);
        //console.log("F_vec =", F_vec);
        err = numeric.norm2(F_vec);
        console.log("Newton iter:", iter, "err =", err);
        if(err < tol) break;
        
        // Build the Jacobian J (2N x 2N).
        for (let i = 0; i < N; i++) {
            // J11 = -0.5*D2 + diag( g*(3*Ur^2 + Ui^2) + V + w_sol )
            diagJ11[i] = g * (3 * Ur[i] * Ur[i] + Ui[i] * Ui[i]) + V[i] + w_sol;
            // J22 = -0.5*D2 + diag( g*(Ur^2 + 3*Ui^2) + V + w_sol )
            diagJ22[i] = g * (Ur[i] * Ur[i] + 3 * Ui[i] * Ui[i]) + V[i] + w_sol;
            // J12 = diag(2 * g * Ur * Ui)
            diagJ12[i] = 2 * g * Ur[i] * Ui[i];
        }
        let J11 = numeric.add(numeric.mul(D2, -0.5), numeric.diag(diagJ11));
        let J22 = numeric.add(numeric.mul(D2, -0.5), numeric.diag(diagJ22));
        let J12 = numeric.diag(diagJ12);
        // Assemble full Jacobian J as a block matrix:
        let top = hconcat(J11, J12);
        let bottom = hconcat(J12, J22);
        let J = vconcat(top, bottom);
        
        // Solve for Newton correction: J * DU = -F_vec.
        let DU = numeric.solve(J, numeric.neg(F_vec));
        
        // Update U: with learning rate lr=1.
        U = numeric.add(U, numeric.mul(lr, DU));
        
        iter += 1;
      }
      
      // Rebuild refined u from U: first N entries are real, next N are imaginary.
      let refined_u = new Array(N);
      for (let i = 0; i < N; i++) {
        refined_u[i] = math.complex(U[i], U[i + N]);
      }
      
      //console.log("Newton refinement completed in", iter, "iterations; final err =", err);
      return [refined_u, err, D2, x];
    }

    function refineNewton(u, params) {
        let lr = 1;
        let err = Infinity;
        let maxIter = 10;
        let iter = 0;
        let u0 = u.slice();
        //console.log("u0=",u0);
        progress = 0;

        // Show the progress bar:
        window.document.getElementById("newtonProgressContainer").style.display = "block";
        //window.document.getElementById("newtonProgressBar").style.width = "0%";
        //window.document.getElementById("newtonProgressBar").setAttribute("aria-valuenow", "0");
        
        do {
            console.log("lr=", lr);
            //params = getParameters()
            [u, err, D2, x] = refineNewtonHelper(u0.slice(), params, lr);
            iter += 1;
            // Update progress (as percentage of maxIter):
            progress = Math.min(100, (iter / maxIter) * 100);
            const progressBar = document.getElementById("newtonProgressBar");
            console.log("progress = "+ progressBar.value);
            const interval = setInterval(() => {
                setTimeout(() => {
                    progressBar.value = progress;
                    progressBar.setAttribute("value", progress);
                }, 100);
                progressBar.value = progress;
                progressBar.setAttribute("value", progress);
            }, 50); //TODO: Investigate web workers https://gemini.google.com/app/7f7019458576a6f5
            //console.log("progressBar.outerHTML=\n"+progressBar.outerHTML);
            //document.getElementById("newtonProgressBar").setAttribute("aria-valuenow", progress);
            //setTimeout(() => {document.getElementById("newtonProgressBar").outerHTML =
            //String.raw`
            //<div id="newtonProgressBar" class="progress-bar" role="progressbar" style="width: ${progress}%;" aria-valuenow="${progress}" aria-valuemin="0" aria-valuemax="100"></div>
            //`}, 0);
            //console.log(document.getElementById("newtonProgressBar"));
            if (document.getElementById("applyAlertToggle").checked && iter % 2 === 0)
            {
                alert(`Newton ${progress}% done\n(press return to continue)`);
            }
            lr *= 0.9;
        } while (err > tol && iter < maxIter);

        if (document.getElementById("applyAlertToggle").checked)
        {
            alert(`Newton done, error = ${err.toExponential(2)} ` + ((err <= tol) ? ' 🎉' : ' ❌') + "\n(press return to continue)" ) ;
        }
        if (err > tol)
        {
            alert(`Newton did not converge, error = ${err.toExponential(2)}. Returning starting ansatz.`);
            return [u0, D2, x];
        }
        progress = 100;
        // Hide the progress bar once Newton is done
        window.document.getElementById("newtonProgressContainer").style.display = "none";
       // window.document.getElementById("newtonProgressBar").outerHTML =
        //String.raw`
        //<div id="newtonProgressBar" class="progress-bar" role="progressbar" style="width: ${progress}%;" aria-valuenow="${progress}" aria-valuemin="0" aria-valuemax="100"></div>
        //`
        
        return [u, D2, x];
    }

    // ----------------------- Plotly Initialization & Update -----------------------
    function initPlots(params) {
      // ODE plot: potential and particle marker.
      let odePotential = pdeGrid.map(x => 0.5 * params.Omega * params.Omega * x * x + params.A * Math.pow(sech(params.b * x), 2));
      let initialODEPotential = 0.5 * params.Omega * params.Omega * params.x0 * params.x0 + params.A * Math.pow(sech(params.b * params.x0), 2);
      
      let odeTracePotential = {
        x: pdeGrid,
        y: odePotential,
        mode: 'lines',
        name: 'ODE Potential'
      };
      let odeTraceParticle = {
        x: [params.x0],
        y: [initialODEPotential],
        mode: 'markers',
        marker: { size: 12, color: 'red' },
        name: 'Particle'
      };
      let odeLayout = {
        title: 'ODE: Particle in Potential',
        xaxis: { title: 'x' },
        yaxis: { title: 'Potential Energy' },
        annotations: [{
          xref: 'paper', yref: 'paper', x: 0.05, y: 0.95,
          text: 'Time: 0.00', showarrow: false, font: { size: 16 }
        }]
      };
      Plotly.newPlot('odePlot', [odeTracePotential, odeTraceParticle], odeLayout);
      
      // PDE plot: potential and soliton density.
      pdePotential = pdeGrid.map(x => 0.5 * params.Omega_pde * params.Omega_pde * x * x + params.A_pde * Math.pow(sech(params.b_pde * x), 2));
      //console.log("u=",u);
      //console.log("pdeGrid=",pdeGrid);
      let density = pdeGrid.map((x, i) => math.abs(u[i]) ** 2);
      let pdeTracePotential = {
        x: pdeGrid,
        y: pdePotential,
        mode: 'lines',
        name: 'PDE Potential'
      };
      let pdeTraceDensity = {
        x: pdeGrid,
        y: density,
        mode: 'lines',
        name: 'Soliton Density |u|²'
      };
      let pdeLayout = {
        title: 'PDE: Soliton in Potential',
        xaxis: { title: 'x' },
        yaxis: { title: 'Energy / Density' },
        annotations: [{
          xref: 'paper', yref: 'paper', x: 0.05, y: 0.95,
          text: 'Time: 0.00', showarrow: false, font: { size: 16 }
        }]
      };
      Plotly.newPlot('pdePlot', [pdeTracePotential, pdeTraceDensity], pdeLayout);
    }

    function updatePlots(params) {
      // Update ODE particle position:
      let currentODEPotential = 0.5 * params.Omega * params.Omega * odeState.x * odeState.x + params.A * Math.pow(sech(params.b * odeState.x), 2);
      Plotly.update('odePlot', {
        x: [[odeState.x]],
        y: [[currentODEPotential]]
      }, {}, [1]);
      Plotly.relayout('odePlot', {'annotations[0].text': 'Time: ' + currentTime.toFixed(2)});
      
      // Update PDE density:
      //console.log("u=",u);
      pdePotential = pdeGrid.map(x => 0.5 * params.Omega_pde * params.Omega_pde * x * x + params.A_pde * Math.pow(sech(params.b_pde * x), 2));
      //console.log("u=",u);
      let density = pdeGrid.map((x, i) => math.abs(u[i]) ** 2);
      let pdeTracePotential = {
        x: pdeGrid,
        y: pdePotential,
        mode: 'lines',
        name: 'PDE Potential'
      };
      let pdeTraceDensity = {
        x: pdeGrid,
        y: density,
        mode: 'lines',
        name: 'Soliton Density |u|²'
      };
      let pdeLayout = {
        title: 'PDE: Soliton in Potential',
        xaxis: { title: 'x' },
        yaxis: { title: 'Energy / Density' },
        annotations: [{
          xref: 'paper', yref: 'paper', x: 0.05, y: 0.95,
          text: `Time: ${currentTime.toFixed(2)}`, showarrow: false, font: { size: 16 }
        }]
      };
      Plotly.newPlot('pdePlot', [pdeTracePotential, pdeTraceDensity], pdeLayout);
    }

    // ----------------------- Simulation Initialization & Loop -----------------------
    function initSimulations() {
      let params = getParameters();
      currentTime = 0;
      // Initialize ODE state:
      odeState = { x: params.x0, v: params.v0 };
      // Initialize PDE grid and initial condition:
      initPDE(params);
      initPlots(params);
    }

    function simulationStep() {
      let params = getParameters();
      // Update ODE state with RK4:
      odeState = rk4Step(odeState.x, odeState.v, params.dt, params);
      currentTime += params.dt;
      
      // Update PDE using our RK4 integrator:
      //console.log("u=",u);
      //pdeStep(params);
      pdeStep_dop853(params);
        
      if (currentTime >= params.T) {
        clearInterval(simInterval);
        simulationRunning = false;
        if (document.getElementById("loopToggle").checked) {
          setTimeout(() => {
            initSimulations();
            simInterval = setInterval(simulationStep, params.dt);
            simulationRunning = true;
          }, 1000);
        }
      }
    }
    
    function plotStep()
    {
        let params = getParameters();
        updatePlots(params);
        if (currentTime >= params.T) {
            clearInterval(plotInterval);
        }
    }
    
    // sleep time expects milliseconds
    function sleep (time) {
      return new Promise((resolve) => setTimeout(resolve, time));
    }
    
    // This function assumes that you already have computed the steady state u, D2, and the potential V as arrays.
    // Also assume that your parameters object `params` contains:
    // - g         (nonlinearity coefficient)
    // - wfreq     (the steady-state frequency)
    // - D2        (the finite difference Laplacian matrix)
    // - V         (the potential vector evaluated on the grid)
    // - u         (the steady state solution, as an array of length N with complex numbers from math.js)
    // - N         (the number of grid points)
    function computeEigenspectrum(params) {
      N = params.N;
      let g = params.g;
      const wfreq = params.wfreq;
      const D2 = params.D2;  // D2 should be an N x N numeric.js matrix
      console.log("D2 =",D2);
      console.log("V =",V);
      V = params.V;    // V is an array of length N
      u = params.u;    // u is an array of N math.js complex numbers
      console.log("V =",V);
      // Build the diagonal matrices.
      // In MATLAB, the matrices M11 and M12 are defined as:
      //   M11 = -(-0.5*D2+diag(2*g*u.*conj(u)+V+wfreq));
      //   M12 = -diag(g*u.*u);
      //   M21 = -conj(M12);
      //   M22 = -conj(M11);
      // and then M = 1i * [M11, M12; M21, M22].
      // In JavaScript we build these blocks as arrays.
      
      // Precompute |u|^2, and u^2.
      let abs2 = u.map(z => math.add(math.multiply(z.re, z.re), math.multiply(z.im, z.im)));
      console.log("abs2 =",abs2);
      let uSquared = u.map(z => math.square(z).re);  // returns a math.js Complex
      console.log("uSquared =",uSquared);
      let two_g_abs2 = abs2.map(val => 2 * g * val);
      console.log("two_g_abs2 =",two_g_abs2);
      let diagM11 = [];
      let diagM12 = [];
      
      // For each i = 0,...,N-1:
      for (let i = 0; i < N; i++) {
        // M11 diagonal entry is 2*g|u_i|^2 + V(i) + wfreq.
        diagM11.push(two_g_abs2[i] + V[i] + wfreq);
        // M12 diagonal entry is g*u_i^2.
        // We will construct these as complex numbers.
        diagM12.push(-math.multiply(g, uSquared[i]));
      }
      console.log("diagM11 =",diagM11);
      
      // Build block matrices with D2.
      // We define A = -0.5*D2 + diag(diagM11) and B = -diag(diagM12)
      // (Note the double negation in the MATLAB code).
      let A = numeric.neg(numeric.add(numeric.mul(D2, -0.5), numeric.diag(diagM11)));  // Because MATLAB: M11 = -(-0.5*D2+diag(...))
      console.log("A =",A);
      // For B, we need a diagonal matrix whose diagonal entries are diagM12, but with a minus sign.
      let B = numeric.diag(diagM12);
      console.log("B =",B);

      // For M21 and M22, we have:
      // M21 = -conj(M12)   and   M22 = -conj(M11)
      // So M21 is the conjugate of B:
      let B_conj = numeric.diag(diagM12.map(x => math.unaryMinus(math.conj(x))));
      console.log("B_conj = ",B_conj);
      // And M22 is:
      let A_conj = numeric.add(numeric.mul(D2, -0.5), numeric.diag(diagM11.map(x => x))); // conj of diag is itself (if real)
      console.log("A_conj = ",A_conj);

      // Now build the full 2N x 2N matrix M.
      // M = 1i * [A, B; B_conj, A_conj].
      let topRow = A.map((row, idx) => row.concat(B[idx]));
      let bottomRow = A_conj.map((row, idx) => B_conj[idx].concat(row));
      let fullMatrix = topRow.concat(bottomRow);
      // Multiply fullMatrix by 1i.
      fullMatrix = fullMatrix.map(row => row.map(val => math.multiply(math.complex(0, 1), val)));
      console.log("fullMatrix =",fullMatrix);
      // Now compute eigenvalues and eigenvectors using math.eigs.
      // math.eigs() accepts a numeric.js matrix or a plain array.
      let eigResult;
      try {
        eigResult = math.eigs(fullMatrix); //TODO: modify it to use mathml instead (maybe if numeric js's doesn't work to find all eigenvalues/eigenvectors but let's see about that
      } catch (err) {
        console.warn("Eigenvalue computation did not fully converge; using partial results.");
        eigResult = {
          values: err.values,
          vectors: err.vectors
        };
      }
      
      console.log("eigResult =",eigResult);
      /*const MlfullMatrix = new mlMatrix.Matrix(fullMatrix);
      let mathMlDecomp = new mlMatrix.EigenvalueDecomposition(MlfullMatrix)
      console.log("eigenvalue decomposition with math-ml = ", mathMlDecomp);*/

      // eigResult.values is an array of complex numbers
      // eigResult.vectors is a 2N x 2N matrix where each column is an eigenvector.
      //TODO: Make synchronous! https://chatgpt.com/c/67f3117e-bb04-8012-a940-91ed82861c0f 
      createModule().then((Module) =>
      {
          let flattened = new Float64Array(2 * N * N);
              for (let i = 0; i < N; i++){
                for (let j = 0; j < N; j++){
                  let z = fullMatrix[i][j];  // assume fullMatrix[i][j] has properties re and im.
                  let idx = 2 * (i * N + j);
                  flattened[idx] = z.re;
                  flattened[idx + 1] = z.im;
                }
              }
              
              // Allocate in the Emscripten heap:
              let ptr = Module._malloc(flattened.length * flattened.BYTES_PER_ELEMENT);
              Module.HEAPF64.set(flattened, ptr/8);
              
              // Call the function.
              let resultPtr = Module.ccall(
                "computeEigenspectrum", // C function name (without underscore, handled by Emscripten)
                "number", // return type
                ["number", "number"], // argument types
                [ptr, N] // arguments: pointer and N
              );
              
              // Read back the eigenvalues (an interleaved array of 2*N doubles).
              let eigenvalues = new Float64Array(Module.HEAPF64.buffer, resultPtr, 2 * N);
              console.log("Eigenvalues (Re, Im):", eigenvalues);
              
              // Free allocated memory.
              Module._free(ptr);
              Module._free(resultPtr);
          
      });
      console.log("here");
      // Determine the effective number of eigenpairs by taking the minimum length:
      let numValues = eigResult.values.length;
      let numVecs = (eigResult.eigenvectors && eigResult.eigenvectors.length) || 0;
      let numValid = Math.min(numValues, numVecs);
      if (numValid < numValues) {
        console.warn(`Mismatch: ${numValues} eigenvalues but only ${numVecs} eigenvectors. Using first ${numValid} pairs.`);
      }

      // Build an array of indices 0,..., numValid-1 and sort them by descending real part:
      let indices = Array.from({length: numValid}, (_, i) => i);
      indices.sort((i, j) => eigResult.values[j].re - eigResult.values[i].re);
      console.log("indices =", indices);

      // Sorted eigenvalues:
      let sortedVals = indices.map(i => eigResult.values[i]);
      console.log("sortedVals =", sortedVals);

      // For eigenvectors, assume each eigenvector is an object with a property "vector" representing the eigenvector.
      // If some eigenvector is missing, we can substitute an array of zeros.
      let vecs = eigResult.eigenvectors;
      let sortedVecs = indices.map(i => {
        if (vecs[i] && vecs[i].vector) {
          return vecs[i].vector;
        } else {
          console.warn(`No eigenvector available for index ${i}; substituting zero vector.`);
          return new Array(N).fill(math.complex(0,0));
        }
      });
      console.log("sortedVecs =", sortedVecs);

      // Combine eigenvector components if desired; for instance, combining the first half and conjugate of the second half.
      let modeVecs = sortedVecs.map(vec => {
        let firstHalf = vec.slice(0, N);
        let secondHalf = vec.slice(N, 2 * N);
        // Combine as: combined = firstHalf + conj(secondHalf)
        let combined = firstHalf.map((val, idx) => math.add(val, math.conj(secondHalf[idx])));
        return combined;
      });

      try
      {
          console.log("sortedVals.length =",sortedVals.length);
          console.log("eigResult.values.length =",eigResult.values.length);
          console.log("sortedVecs.length =",sortedVecs.length);
          console.log("eigResult.eigenvectors.length =",eigResult.eigenvectors.length);
      }
      catch (err)
      {
          console.log(`Error when printing, ${err}`);
      }
      
      let returnVal = {eigenvalues: [], eigenmodes: []};
      
      if (sortedVals !== undefined && eigResult !== undefined && eigResult.values !== undefined)
      {
          returnVal.eigenvalues = ((sortedVals.length >= eigResult.values.length) ? sortedVals : eigResult.values);
      }
      if (sortedVecs !== undefined && eigResult !== undefined && eigResult.eigenvectors !== undefined)
      {
          returnVal.eigenmodes = ((sortedVecs.length >= eigResult.eigenvectors.length) ? modeVecs : eigResult.eigenvectors);
      }
      
      return returnVal;
    }

    // Example of using the function:
    // Assume params is built from getParameters() and that you have computed u, D2, V, N, g, wfreq as appropriate.
    document.getElementById("computeSpectrumBtn").addEventListener("click", function() {
      let params = getParameters();
      // You must compute or obtain u, D2, V, and set N, g and wfreq appropriately.
      // For example:
      //   params.u = computed steady-state solution as an array of math.complex numbers (length N)
      //   params.D2 = numeric.js matrix for the Laplacian (N x N)
      //   params.V  = potential array (length N)
      //   params.N  = N
      //   params.g  = nonlinearity coefficient (e.g. -1 for focusing)
      //   params.wfreq = the chemical potential or steady-state frequency.
      let {x_min, x_max, dx, x0, A_sol, v0} = params;
      params.N = Math.floor((x_max - x_min) / dx);
      N = params.N;
      params.g = -1;
      params.wfreq = params.Omega;
      let x;
      u = new Array(N);
      pdeGrid = new Array(N);
      for (let i = 0; i < params.N; i++) {
          pdeGrid[i] = x_min + i * dx;
          x = pdeGrid[i];
          let amplitude = params.A_sol * sech(params.A_sol * (x - x0));
          //let phase = v0 * x;
          u[i] = math.complex(amplitude, 0);
          console.log("u[",i,"] = ", u[i], ", x[",i,"] = ", pdeGrid[i], ", dx = ",dx);
      }
      
      [params.u, params.D2, x] = refineNewton(u, params);
      params.V = new Array(N);
      for (let i = 0; i < N; i++){
          params.V[i] = potentialForRefinement(x[i], params);
      }

      console.log("u = ", params.u, ", D2 = ", params.D2);
      spectrum = computeEigenspectrum(params);
      console.log("Eigenvalues:", spectrum.eigenvalues);
      console.log("Eigenmodes:", spectrum.eigenmodes);

      // Plot the eigenvalues (Re vs Im) on the left.
      let eigenvalueTrace = {
        x: spectrum.eigenvalues.map(z => z.re),
        y: spectrum.eigenvalues.map(z => z.im),
        mode: 'markers',
        marker: { size: 8 },
        name: 'Eigenvalues'
      };
      let eigenvalueLayout = {
        title: 'Eigenvalue Spectrum',
        xaxis: { title: 'Re(λ)' },
        yaxis: { title: 'Im(λ)' }
      };
      document.getElementById("eigenvaluePlot").innerHTML = `<b style='color:red'>${spectrum.eigenvalues.length} eigenvalues and ${spectrum.eigenmodes.length} eigenvectors found</b> (numeric.js sucks by the way)`
      Plotly.newPlot('eigenvaluePlot', [eigenvalueTrace], eigenvalueLayout);

      // Set the global variable and plot the first eigenmode:
      currentEigenMode = 0;
      document.getElementById("stabilityPlots").style.display = "block";
      updateEigenmodePlot(params);
    });

    // ----------------------- Event Listeners -----------------------
    document.getElementById("startBtn").addEventListener("click", function() {
        //if (!simulationRunning)
        //{
            // Set up an interval to update the progress bar every second.
            if (window.loadedCPPFunctions == false)
            {
                console.log("error, functions not loaded yet");
                return;
            }
            progress = 0;
            let progressBar = document.getElementById("newtonProgressBar");
            let progressInterval = setInterval(() => {
                //console.log(`hi ${progress}`);
              
              // Update the progress bar using the global progress variable.
              progressBar.setAttribute("value", progress);
              progressBar.value = progress;
              if (progress >= 100) {
                  
                clearInterval(progressInterval);
              }
            }, 0);
            let params = getParameters();
            if (params.dt > 0.7071067811865476*params.dx*params.dx)
            {
                alert("Warning: CFL condition violated.");
            }
            initSimulations();
            simInterval = setInterval(simulationStep, 0);
            plotInterval = setInterval(plotStep, params.stepsPerUpdate);
            simulationRunning = true;
        //}
    });
    document.getElementById("stopBtn").addEventListener("click", function() {
      if (simulationRunning) {
        clearInterval(simInterval);
        clearInterval(plotInterval)
        simulationRunning = false;
      }
    });
    window.addEventListener("resize", function() {
      Plotly.Plots.resize(document.getElementById("odePlot"));
      Plotly.Plots.resize(document.getElementById("pdePlot"));
    });
    
    </script>

    <!-- Bootstrap JS and dependencies -->
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    </body>
    </html>
