<!--open myfunc.cpp ParticleVsSolitonDynamics.html-->
<!--run locally: python3 -m http.server 8000-->
<!--Then go to the following site in a browser: http://localhost:8000/ParticleVsSolitonDynamics.html -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive ODE &amp; PDE Dynamics Simulation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
  <!-- Explicit Plotly v2.16.1 -->
  <script src="https://cdn.plot.ly/plotly-2.16.1.min.js"></script>
  <!-- MathJax for rendering LaTeX -->
<!--  <script id="MathJax-script" async-->
<!--    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <!-- Math.js for complex arithmetic -->
  <script src="https://unpkg.com/mathjs/lib/browser/math.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.12.1"></script> <!-- Example Usage: const MlfullMatrix = new mlMatrix.Matrix(fullMatrix); let mathMlDecomp = new mlMatrix.EigenvalueDecomposition(MlfullMatrix); console.log("eigenvalue decomposition with math-ml = ", mathMlDecomp);-->
  <script src="https://cdn.jsdelivr.net/npm/numeric@1.2.6/numeric-1.2.6.min.js"></script> <!-- numeric.js for linear algebra operations -->
  <!-- In your HTML file, include myfunc.js after your other script tags, or import it as a module -->
  <script type="module">
    window.loadedCPPFunctions = false;
    // Import the module creation function. Adjust the path as needed.
    // This below ⬇️ worked!
    // emcc myfunc.c -Os -s WASM=1 -s EXPORT_ES6=1 -s MODULARIZE=1 -s EXPORT_NAME="createModule" -s EXPORTED_FUNCTIONS='["_sech"]' -s EXPORTED_RUNTIME_METHODS="['ccall']" -o myfunc.js
    import createModule from './myfunc.js';
    // When you call createModule, it returns a Promise that resolves once the module is initialized.
    console.log("Hello");
    window.cppReady = createModule().then((Module) => {
      window.Module = Module;
      // Now you can call your C function from JavaScript.
      const result = Module.ccall('sech',      // C function name
                                   'number', // return type
                                   ['number'], // argument type(s)
                                   [Math.PI / 4]); // arguments
      console.log("Result of sech(Math.PI/4) =", result);
      window.sech = Module.cwrap('sech', 'number', ['number']); //put sech in global scope
      console.log("Result of sech(Math.PI/4) =", sech(Math.PI / 4));
      window.computeEigenspectrumCpp = Module.cwrap('computeEigenspectrum', 'number', ["number", "number"]);
      window.refineCpp = Module.cwrap('refineCpp', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
      window.stepForPlotInterval = Module.cwrap('stepForPlotInterval', null, ['number']);
      window.setSimParameters    = Module.cwrap('setSimParameters', null, ['number','number','number','number','number','number','number','number','number','number','number','number','number','number','number', 'number']);
      // getters for ode and pde simulations
      window.getXParticle  = Module.cwrap('getXParticle','number',[]);
      window.getVParticle  = Module.cwrap('getVParticle','number',[]);
      window.getCurrentTime  = Module.cwrap('getCurrentTime','number',[]);
      window.getPsiPointer  = Module.cwrap('getPsiPointer','number',[]);
      window.freePsi = Module.cwrap('freePsiBuffer', null, []);
      window.setCurrentTime = Module.cwrap('setCurrentTime', null, ['number']);

      window.loadedCPPFunctions = true;
      // You can now use this function in your performance-critical code.
      // For example, if you want to call f(x) many times in your simulation, wrap this call.
    }).catch(err => {
      console.error("Error initializing module", err);
    });
  </script>
  
</head>
<body>
<div class="container-fluid">
  <h1 class="text-center">ODE &amp; PDE Dynamics Simulation</h1>
  <div class="text-center mb-3">
    <p><strong>ODE:</strong> Simulates a particle of mass \( m \) in the effective potential \( V(x) = \frac{1}{2} \Omega^2 x^2 + A \, \text{sech}^2(bx) \).</p>
    <p><strong>PDE:</strong> Evolves the focusing 1D nonlinear Schrödinger equation (NLS)
    \[
    i u_t = -\frac{1}{2} u_{xx} + V(x) u - |u|^2 u,
    \]
    with periodic boundary conditions, using a finite-difference RK4 scheme.</p>
    <p><strong>Initial Condition PDE:</strong> \( u(x, 0) = A_{\text{sol}} \, \text{sech}(A_{\text{sol}} (x - x_0)) \cdot e^{i v_0 x} \), optionally refined via Newton's method or Levenberg–Marquardt.</p>
  </div>
  <!-- Parameter Input Form -->
  <form id="paramsForm">
    <div class="row">
      <!-- Shared parameters -->
      <div class="col-md-4">
        <h3>Shared Parameters</h3>
        <div class="form-group">
          <label for="x0">Initial Position \( x_0 \)</label>
          <input type="number" step="any" class="form-control" id="x0" value="0">
        </div>
        <div class="form-group">
          <label for="v0">Initial Velocity \( v_0 \)</label>
          <input type="number" step="any" class="form-control" id="v0" value="0">
        </div>
        <div class="form-group">
          <label for="T">Total Time \( T \)</label>
          <input type="number" step="any" class="form-control" id="T" value="100">
        </div>
        <div class="form-group">
          <label for="dt">Time Step \( \Delta_t \)</label>
          <input type="number" step="any" class="form-control" id="dt" value="0.001">
        </div>
        <div class="form-group">
          <label for="stepsPerUpdate">How often to update the plot (milli-seconds)</label>
          <input type="number" step="1" min="1" class="form-control" id="stepsPerUpdate" value="100">
        </div>
<!--        <h4>Spatial Parameters</h4>-->
        <div class="form-group">
          <label for="dx">Spatial Step \( \Delta_x \)</label>
          <input type="number" step="any" class="form-control" id="dx" value="0.05">
        </div>
        <div class="form-group">
          <label for="x_min">\( x_{\text{min}} \)</label>
          <input type="number" step="any" class="form-control" id="x_min" value="-10">
        </div>
        <div class="form-group">
          <label for="x_max">\( x_{\text{max}} \)</label>
          <input type="number" step="any" class="form-control" id="x_max" value="10">
        </div>
      </div>
      <!-- ODE parameters -->
      <div class="col-md-4">
        <h3>ODE Parameters</h3>
        <div class="form-group">
          <label for="m">Mass \( m \)</label>
          <input type="number" step="any" class="form-control" id="m" value="1">
        </div>
        <div class="form-group">
          <label for="Omega">\( \Omega \)</label>
          <input type="number" step="any" class="form-control" id="Omega" value="0.2">
        </div>
        <div class="form-group">
          <label for="A">Amplitude \( A \)</label>
          <input type="number" step="any" class="form-control" id="A" value="1">
        </div>
        <div class="form-group">
          <label for="b">Width Factor \( b \)</label>
          <input type="number" step="any" class="form-control" id="b" value="1">
        </div>
      </div>
      <!-- PDE parameters -->
      <div class="col-md-4">
        <h3>PDE Parameters</h3>
        <div class="form-group">
          <label for="A_sol">Soliton Amplitude \( A_{\text{sol}} \)</label>
          <input type="number" step="any" class="form-control" id="A_sol" value="1">
        </div>
        <div class="form-group">
          <label for="omega">Chemical Potential \( \omega \)</label>
          <input type="number" step="any" class="form-control" id="omega" value="0.5">
        </div>
        <div class="form-group">
          <label for="Omega_pde">\( \Omega_{\text{pde}} \)</label>
          <input type="number" step="any" class="form-control" id="Omega_pde" value="0.2">
        </div>
        <div class="form-group">
          <label for="A_pde">\( A_{\text{pde}} \)</label>
          <input type="number" step="any" class="form-control" id="A_pde" value="1">
        </div>
        <div class="form-group">
          <label for="b_pde">\( b_{\text{pde}} \)</label>
          <input type="number" step="any" class="form-control" id="b_pde" value="1">
        </div>
        <div class="form-group">
          <label for="solverDropdown">Steady-State Solver</label>
          <div class="dropdown">
            <button class="btn btn-primary dropdown-toggle" type="button" id="solverDropdown" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
              <span id="solverLabel">Newton: \( \vec{U}_{k+1} = \vec{U}_k - J_k^{-1} \mathcal{F}(\vec{U}_k) \)</span>
            </button>
            <div class="dropdown-menu" aria-labelledby="solverDropdown">
              <a class="dropdown-item solver-option" data-method="newton">
                Newton: \( \vec{U}_{k+1} = \vec{U}_k - J_k^{-1} \mathcal{F}(\vec{U}_k) \)
              </a>
              <a class="dropdown-item solver-option" data-method="lm">
                Levenberg–Marquardt: \( \min_{\vec{U}} \| \mathcal{F}(\vec{U}) \|^2 \)
              </a>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- Spatial parameters -->
<!--    <div class="row">-->
<!--      <div class="col-md-4">-->
<!--        <h4>Spatial Parameters</h4>-->
<!--        <div class="form-group">-->
<!--          <label for="dx">Spatial Step \( \Delta x \)</label>-->
<!--          <input type="number" step="any" class="form-control" id="dx" value="0.27">-->
<!--        </div>-->
<!--        <div class="form-group">-->
<!--          <label for="x_min">\( x_{\text{min}} \)</label>-->
<!--          <input type="number" step="any" class="form-control" id="x_min" value="-20">-->
<!--        </div>-->
<!--        <div class="form-group">-->
<!--          <label for="x_max">\( x_{\text{max}} \)</label>-->
<!--          <input type="number" step="any" class="form-control" id="x_max" value="20">-->
<!--        </div>-->
<!--      </div>-->
<!--    </div>-->
  </form>
  
  <!-- Simulation Control Buttons -->
  <div class="my-3">
    <button id="startBtn" class="btn btn-success">Start</button>
    <button id="stopBtn" class="btn btn-danger">Stop</button>
    <button id="resetBtn" class="btn btn-warning">Reset</button>
    <button id="computeSpectrumBtn" class="btn btn-primary">Compute Steady-State Spectrum</button>
    <div class = "row" style="text-align:center">
        <div class = "col">
            <label class="ml-2">
              <input type="checkbox" id="loopToggle"> Auto-loop
            </label>
        </div>
    </div>
    <div class = "row" style="text-align:center">
        <div class = "col">
            <label class="ml-2">
              <input type="checkbox" id="applyNewtonToggle" unchecked>
<!--                  Apply minimization routine to \(u(x,0) = A_{\text{sol}} \, \text{sech}\left(A_{\text{sol}} (x - x_0)\right)\) that minimizes the residual vector \(\mathcal{F} = \begin{pmatrix} \texttt{diag}\left(\left(\omega - \left( \vec{A}^2 +  \vec{B}^2\right) + V\right) \vec{A}\right) - \dfrac{D^{\text{(1D)}}_2}{2}  \vec{A}   \\[0.2cm] \texttt{diag}\left(\left(\omega - \left( \vec{A}^2 +  \vec{B}^2\right) + V\right) \vec{B}\right) - \dfrac{D^{\text{(1D)}}_2}{2}  \vec{B} \end{pmatrix}\), where \( \vec{A} \) is the real-part and \( \vec{B} \) is the imaginary part of the steady-state vector \( \vec{U} \), to get the steady-state solution starting point for bright-soliton simulation.-->
                Apply steady-state solver to minimize residual \( \mathcal{F} \) for initial soliton \( u(x,0) = A_{\text{sol}} \, \text{sech}(A_{\text{sol}}(x - x_0)) \)
            </label>
        </div>
    </div>
    <div class = "row" style="text-align:center; display:none; margin-bottom: 10px;" id = "Fres">
    </div>
<!--    <br>-->
<!--    <label class="ml-2">-->
<!--      <input type="checkbox" id="applyAlertToggle" unchecked> Alert Newton Progress-->
<!--    </label>-->
  </div>
  
<!--  <div class="row">-->
<!--      <div class = "col" id="newtonProgressContainer" style="display:none; margin-bottom: 10px;">-->
<!--        <label>Newton Refinement Progress:</label>-->
<!--        <progress id="newtonProgressBar" value={0} max="100"></progress>-->
<!--      </div>-->
<!--  </div>-->

  <!-- Simulation Plots: Two columns side-by-side -->
  <div class="row">
    <div class="col">
      <div id="odePlot"></div>
    </div>
    <div class="col">
      <div id="pdePlot"></div>
    </div>
  </div>
  
    <!-- Eigen Mode Decomposition Plots: Four columns side-by-side -->
    <div id = "stabilityPlots" style="display:none; margin-bottom: 10px;">
        <div class="row">
            <div class="col">
                <div id="eigenvaluePlot" style="height:300px; width:100%;"></div>
            </div>
            <div class="col">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <button id="prevModeBtn" class="btn btn-secondary">Previous Mode</button>
                    <span id="modeCounter">Mode: 0</span>
                    <button id="nextModeBtn" class="btn btn-secondary">Next Mode</button>
                </div>
                <div id="eigenmodePlot" style="height:300px; width:100%;">
                </div>
            </div>
        </div>
        <div class = "row">
            <div class = "col" style="text-align:center">
                <button id="closeStab" class="btn btn-danger" onclick = "document.getElementById('stabilityPlots').style.display='none';">Close</button>
            </div>
        </div>
    </div>
</div>
    
<!-- Simulation JavaScript -->
<script>
    // Global simulation variables
    const A = new mlMatrix.Matrix([
        [1, 2],
        [3, 4]
      ]); // Should log the ML namespace
    console.log("A =",A);
    window.useLM = false;

    document.querySelectorAll(".solver-option").forEach(item => {
    item.addEventListener("click", function () {
      const method = this.getAttribute("data-method");
      const latex = this.innerHTML;
      document.getElementById("solverLabel").innerHTML = latex;
      window.useLM = (method === "lm");
      //MathJax.Hub.Queue(["Typeset", MathJax.Hub, "solverLabel"]);
    });
    });
    let simInterval = null;
    let currentTime = 0;
    let simulationRunning = false;
    let tol = 1e-10; //For Newton refinement
    let progress = 0; //For Newton refinement
    let V;
    // Global variable to track which eigenmode to display.
    let currentEigenMode = 0;
    let spectrum;
    
    function toLatexExp(x, precision = 2)
    {
        const str = x.toExponential(precision); // e.g. "1.23e-4"
        const [mantissa, exp] = str.split('e');
        const sign = exp.startsWith('-') ? '-' : '+';
        const power = exp.replace(/^[+-]/, ''); // remove + or -
        return `${mantissa} \\times 10^{${sign}${power}}`;
    }
    // This function updates the eigenmode plot for the mode at index currentEigenMode.
    function updateEigenmodePlot(params)
    {
        // Ensure we have at least one eigenmode:
        if (!spectrum || !spectrum.eigenmodes || spectrum.eigenmodes.length === 0) return;
        console.log("currentEigenMode =",currentEigenMode);
        // Get the current eigenmode:
        let mode = spectrum.eigenmodes[currentEigenMode];
        //console.log("mode "+currentEigenMode+" = ",mode);
        // Create a grid for x:
        let xgrid = linspace(params.x_min, params.x_max, params.N);
        //console.log("x_grid.length=",xgrid.length,"mode.length=",mode.length);

        // Set up three traces:
        let modeRealTrace =
        {
            x: xgrid,
            y: mode.map(z => z.re),
            mode: 'lines',
            name: 'Real part'
        };
        let modeImagTrace =
        {
            x: xgrid,
            y: mode.map(z => z.im),
            mode: 'lines',
            name: 'Imaginary part'
        };
        let modeNormTrace =
        {
            x: xgrid,
            y: mode.map(z => z.re*z.re + z.im*z.im),
            mode: 'lines',
            name: '|Mode|²'
        };

        const ev = spectrum.eigenvalues[currentEigenMode];
        const reLatex = toLatexExp(ev.re, 2);
        const imLatex = Math.abs(ev.im).toFixed(2);
        const imSign = ev.im >= 0 ? '+' : '-';

        const evString = `\\text{Eigenmode Details, } \\lambda = \\left(${reLatex}\\right) ${imSign} ${imLatex}\\,i`;

        let modeLayout =
        {
            title: `$${evString}$`,
            xaxis: { title: 'x' },
            yaxis: { title: 'Value' },
            annotations:
            [{
                xref: 'paper', yref: 'paper', x: 0.05, y: 0.95,
                text: `Mode: ${currentEigenMode}`, showarrow: false, font: { size: 16 }
            }]
        };
        Plotly.newPlot('eigenmodePlot', [modeRealTrace, modeImagTrace, modeNormTrace], modeLayout);
        // Update the counter
        document.getElementById("modeCounter").textContent = `Mode: ${currentEigenMode}`;
    }

    // Setup the event listeners for the buttons
    document.getElementById("prevModeBtn").addEventListener("click", function()
    {
        // Wrap around if needed:
        if (spectrum && spectrum.eigenmodes)
        {
            currentEigenMode = (currentEigenMode - 1 + spectrum.eigenmodes.length) % spectrum.eigenmodes.length;
            updateEigenmodePlot(getParameters());
        }
    });

    document.getElementById("nextModeBtn").addEventListener("click", function()
    {
        if (spectrum && spectrum.eigenmodes)
        {
            currentEigenMode = (currentEigenMode + 1) % spectrum.eigenmodes.length;
            updateEigenmodePlot(getParameters());
        }
    });

    // ODE state (position and velocity)
    let odeState = {x: 0, v: 0};

    // PDE variables
    let pdeGrid = []; // spatial grid for PDE
    let pdePotential = []; // PDE Potential
    let u = [];       // array of math.complex objects for u(x,t)
    let N = 0;        // number of spatial grid points
    let k = [];       // wavenumber array for FFT
    let U_pde = [];
    // Retrieve parameters from input fields
    function getParameters()
    {
        return {
            // Shared
            x0: (parseFloat(document.getElementById("x0").value) || 0),
            v0: (parseFloat(document.getElementById("v0").value) || 0),
            T: (parseFloat(document.getElementById("T").value) || 0),
            dt: (parseFloat(document.getElementById("dt").value) || 0),
            stepsPerUpdate: (parseInt(document.getElementById("stepsPerUpdate").value) || 0),
            // ODE
            m: (parseFloat(document.getElementById("m").value) || 0),
            Omega: (parseFloat(document.getElementById("Omega").value) || 0),
            A: (parseFloat(document.getElementById("A").value) || 0),
            b: (parseFloat(document.getElementById("b").value) || 0),
            // PDE
            A_sol: (parseFloat(document.getElementById("A_sol").value) || 0),
            omega: (parseFloat(document.getElementById("omega").value) || 0),
            Omega_pde: (parseFloat(document.getElementById("Omega_pde").value) || 0),
            A_pde: (parseFloat(document.getElementById("A_pde").value) || 0),
            b_pde: (parseFloat(document.getElementById("b_pde").value) || 0),
            // Spatial parameters (PDE)
            dx: (parseFloat(document.getElementById("dx").value) || 0),
            x_min: (parseFloat(document.getElementById("x_min").value) || 0),
            x_max: (parseFloat(document.getElementById("x_max").value) || 0),
            N: Math.floor( ( parseFloat(document.getElementById("x_max").value) - parseFloat(document.getElementById("x_min").value) ) / parseFloat(document.getElementById("dx").value) ),
            g: -1,
            wfreq: (parseFloat(document.getElementById("omega").value) || 0)
        };
    }

    function linspace(a, b, n)
    {
        let arr = [];
        let step = (b - a) / (n - 1);
        for(let i = 0; i < n; i++)
        {
            arr.push(a + step * i);
        }
        return arr;
    }

    // ---------------------- ODE Simulation ----------------------
    function odeRHS(x, v, params)
    {
        //(-Ω² x + 2 A b sech²(bx) tanh(bx)) / m
        let acceleration = (-params.Omega * params.Omega * x + 2 * params.A * params.b * Math.pow(sech(params.b * x), 2) * Math.tanh(params.b * x)) / params.m;
        return {dx: v, dv: acceleration};
    }

    function rk4Step(x, v, dt, params)
    {
        let k1 = odeRHS(x, v, params);
        let k2 = odeRHS(x + 0.5 * dt * k1.dx, v + 0.5 * dt * k1.dv, params);
        let k3 = odeRHS(x + 0.5 * dt * k2.dx, v + 0.5 * dt * k2.dv, params);
        let k4 = odeRHS(x + dt * k3.dx, v + dt * k3.dv, params);
        let x_new = x + (dt/6) * (k1.dx + 2*k2.dx + 2*k3.dx + k4.dx);
        let v_new = v + (dt/6) * (k1.dv + 2*k2.dv + 2*k3.dv + k4.dv);
        return {x: x_new, v: v_new};
    }

    // ----------------------- PDE Simulation using RK4 -----------------------
    // We discretize the PDE: i u_t = -0.5 u_xx - |u|^2 u + V(x) u
    // The right-hand side is: u_t = i*(0.5*u_xx + |u|^2*u - V(x)*u)
    // using finite differences (with periodic BCs) for u_xx.

    // Trapezoidal integration helper.
    function trapz(y, x)
    {
        let sum = 0;
        for (let i = 0; i < y.length - 1; i++)
        {
            sum += 0.5 * (y[i] + y[i+1]) * (x[i+1] - x[i]);
        }
        return sum;
    }
    
    //////////////////////////////////
    // SolveOde (main function)
    //
    // input:
    //   func: ordinary differential equation (ODE) you want to specify
    //   solver: rkf45, dopri5, or dop853
    //   param: Parameters for ODE
    //   start:
    //   end:
    //   h: step
    //   amt: initial values (number[])
    //
    // output: TypeResult
    //   [
    //      number[],    // x
    //      number[][]   // vector of y
    //   ]
    //////////////////////////////////
    function SolveOde(func, solver, param, start, end, h, amt)
    {
        var n = Math.floor((end - start) / h);
        var t = start;
        var x = Array(n + 1);
        var y = Array(n + 1);
        for (var i = 0; i < n - 1; i++)
        {
            x[i] = t;
            y[i] = amt;
            amt = solver(func, param, amt, t, h, false)[0];
            t += h;
        }
        // last - 1
        x[n - 1] = t;
        y[n - 1] = amt;
        // last
        amt = solver(func, param, amt, t, end - t, false)[0];
        x[n] = end;
        y[n] = amt;
        return [x, y];
    }
    
    // Dormand-Prince method order 8
    // Reference
    // dop853.f
    // http://www.unige.ch/~hairer/software.html
    function dop853(func, param, x, t, h, adaptive)
    {
        function calc(param, x, t, h, adaptive)
        {
            var k1 = func(x, param, t);
            var k2 = func(adds(x, multiple(5.26001519587677318785587544488e-2 * h, k1)), param, t + 0.526001519587677318785587544488e-1 * h);
            var k3 = func(adds(x, multiple(1.97250569845378994544595329183e-2 * h, k1), multiple(5.91751709536136983633785987549e-2 * h, k2)), param, t + 0.789002279381515978178381316732e-1 * h);
            var k4 = func(adds(x, multiple(2.95875854768068491816892993775e-2 * h, k1), multiple(8.87627564304205475450678981324e-2 * h, k3)), param, t + 0.118350341907227396726757197510 * h);
            var k5 = func(adds(x, multiple(2.41365134159266685502369798665e-1 * h, k1), multiple(-8.84549479328286085344864962717e-1 * h, k3), multiple(9.24834003261792003115737966543e-1 * h, k4)), param, t + 0.281649658092772603273242802490 * h);
            var k6 = func(adds(x, multiple(3.7037037037037037037037037037e-2 * h, k1), multiple(1.70828608729473871279604482173e-1 * h, k4), multiple(1.25467687566822425016691814123e-1 * h, k5)), param, t + 0.333333333333333333333333333333 * h);
            var k7 = func(adds(x, multiple(3.7109375e-2 * h, k1), multiple(1.70252211019544039314978060272e-1 * h, k4), multiple(6.02165389804559606850219397283e-2 * h, k5), multiple(-1.7578125e-2 * h, k6)), param, t + 0.25 * h);
            var k8 = func(adds(x, multiple(3.70920001185047927108779319836e-2 * h, k1), multiple(1.70383925712239993810214054705e-1 * h, k4), multiple(1.07262030446373284651809199168e-1 * h, k5), multiple(-1.53194377486244017527936158236e-2 * h, k6), multiple(8.27378916381402288758473766002e-3 * h, k7)), param, t + 0.307692307692307692307692307692 * h);
            var k9 = func(adds(x, multiple(6.24110958716075717114429577812e-1 * h, k1), multiple(-3.36089262944694129406857109825 * h, k4), multiple(-8.68219346841726006818189891453e-1 * h, k5), multiple(2.75920996994467083049415600797e1 * h, k6), multiple(2.01540675504778934086186788979e1 * h, k7), multiple(-4.34898841810699588477366255144e1 * h, k8)), param, t + 0.651282051282051282051282051282 * h);
            var k10 = func(adds(x, multiple(4.77662536438264365890433908527e-1 * h, k1), multiple(-2.48811461997166764192642586468 * h, k4), multiple(-5.90290826836842996371446475743e-1 * h, k5), multiple(2.12300514481811942347288949897e1 * h, k6), multiple(1.52792336328824235832596922938e1 * h, k7), multiple(-3.32882109689848629194453265587e1 * h, k8), multiple(-2.03312017085086261358222928593e-2 * h, k9)), param, t + 0.6 * h);
            var k11 = func(adds(x, multiple(-9.3714243008598732571704021658e-1 * h, k1), multiple(5.18637242884406370830023853209 * h, k4), multiple(1.09143734899672957818500254654 * h, k5), multiple(-8.14978701074692612513997267357 * h, k6), multiple(-1.85200656599969598641566180701e1 * h, k7), multiple(2.27394870993505042818970056734e1 * h, k8), multiple(2.49360555267965238987089396762 * h, k9), multiple(-3.0467644718982195003823669022 * h, k10)), param, t + 0.857142857142857142857142857142 * h);
            var k12 = func(adds(x, multiple(2.27331014751653820792359768449 * h, k1), multiple(-1.05344954667372501984066689879e1 * h, k4), multiple(-2.00087205822486249909675718444 * h, k5), multiple(-1.79589318631187989172765950534e1 * h, k6), multiple(2.79488845294199600508499808837e1 * h, k7), multiple(-2.85899827713502369474065508674 * h, k8), multiple(-8.87285693353062954433549289258 * h, k9), multiple(1.23605671757943030647266201528e1 * h, k10), multiple(6.43392746015763530355970484046e-1 * h, k11)), param, t + h);
            var x_ = adds(x, multiple(5.42937341165687622380535766363e-2 * h, k1), multiple(4.45031289275240888144113950566 * h, k6), multiple(1.89151789931450038304281599044 * h, k7), multiple(-5.8012039600105847814672114227 * h, k8), multiple(3.1116436695781989440891606237e-1 * h, k9), multiple(-1.52160949662516078556178806805e-1 * h, k10), multiple(2.01365400804030348374776537501e-1 * h, k11), multiple(4.47106157277725905176885569043e-2 * h, k12));
            if (!adaptive)
            {
                return [x_, null];
            }
            var delta5 = adds(multiple(0.1312004499419488073250102996e-1, k1), multiple(-0.1225156446376204440720569753e+1, k6), multiple(-0.4957589496572501915214079952, k7), multiple(0.1664377182454986536961530415e+1, k8), multiple(-0.3503288487499736816886487290, k9), multiple(0.3341791187130174790297318841, k10), multiple(0.8192320648511571246570742613e-1, k11), multiple(-0.2235530786388629525884427845e-1, k12));
            var delta3 = adds(multiple(-0.189800754072407617468755659980, k1), multiple(4.45031289275240888144113950566, k6), multiple(1.89151789931450038304281599044, k7), multiple(-5.8012039600105847814672114227, k8), multiple(-0.422682321323791962932445679177, k9), multiple(-1.52160949662516078556178806805e-1, k10), multiple(2.01365400804030348374776537501e-1, k11), multiple(0.0226517921983608258118062039631, k12));
            var err5 = 0;
            var err3 = 0;
            for (var i = 0; i < x.length; i++)
            {
                var sc = adaptive.atol[i] +
                    Math.max(Math.abs(x[i]), Math.abs(x_[i])) * adaptive.rtol[i];
                err5 += Math.pow((delta5[i] / sc), 2);
                err3 += Math.pow((delta3[i] / sc), 2);
            }
            var denominator = (err5 !== 0 || err3 !== 0) ? err5 + 0.01 * err3 : 1;
            var err = Math.abs(h) * err5 * Math.sqrt(1 / (x.length * denominator));
            return [x_, err];
        }; // end of calc
        var options = (adaptive === false) ? undefined : (function ()
        {
            var atol = [];
            var rtol = [];
            var userOptions = (typeof adaptive === "boolean") ? undefined : adaptive;
            for (var i = 0; i < x.length; i++)
            {
                var a = userOptions ?
                    (Array.isArray(userOptions.atol) ? userOptions.atol[i] :
                        userOptions.atol) : undefined;
                var r = userOptions ?
                    (Array.isArray(userOptions.rtol) ? userOptions.rtol[i] :
                        userOptions.rtol) : undefined;
                atol.push(((a === 0 && r === 0) || typeof a === "undefined" || a < 0) ?
                    1e-12 : a);
                rtol.push((typeof r === "undefined" || r < 0) ? 1e-6 : r);
            }
            return {
                atol: atol,
                rtol: rtol,
                maxiter: userOptions === null || userOptions === void 0 ? void 0 : userOptions.maxiter,
                fac: userOptions === null || userOptions === void 0 ? void 0 : userOptions.fac,
                facmax: userOptions === null || userOptions === void 0 ? void 0 : userOptions.facmax,
                facmin: userOptions === null || userOptions === void 0 ? void 0 : userOptions.facmin,
            };
        })();
        return _ode(calc, param, x, t, h, options);
    }
    
    function zip()
    {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++)
        {
            args[_i] = arguments[_i];
        }
        return Array.from(Array(Math.min.apply(Math, args.map(function (v) { return v.length; }))), function (_, i) {
            return args.map(function (v) { return v[i]; });
        });
    }
    function adds()
    {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++)
        {
            args[_i] = arguments[_i];
        }
        return zip.apply(void 0, args).map(function (v)
        {
            return v.reduce(function (a, b) { return a + b; });
        });
    }
    function multiple(a, b)
    {
        return b.map(function (v)
        {
            return a * v;
        });
    }
    //////////////////////////////////
    // Reference
    // Ernst Hairer, Gerhard Wanner, Syvert P. Nørsett.
    // Solving Ordinary Differential Equations I: Nonstiff Problems.
    // Springer.
    //////////////////////////////////
    function _ode(func, param, x, t, h, adaptive)
    {
        var _a;
        if (!adaptive)
        {
            var x_ = func(param, x, t, h)[0];
            return [x_, t + h, h];
        }
        var maxiter = (_a = adaptive.maxiter) !== null && _a !== void 0 ? _a : 100;
        var facmax = 5;
        if (adaptive.facmax && adaptive.facmax > 0)
        {
            facmax = adaptive.facmax;
        }
        var facmin = 0.1;
        if (adaptive.facmin && adaptive.facmin > 0)
        {
            facmin = adaptive.facmin;
        }
        var fac = 0.9;
        if (adaptive.fac && adaptive.fac > 0)
        {
            fac = adaptive.fac;
        }
        var h_ = h;
        var i = 0;
        while (i++ < maxiter)
        {
            var _b = func(param, x, t, h_,
            {
                atol: adaptive.atol,
                rtol: adaptive.rtol
            }), x_ = _b[0], err = _b[1];
            if (!err)
            {
                break;
            }
            var t_ = t + h_;
            h_ *= Math.min(facmax, Math.max(facmin, fac * (Math.pow((1 / err), 0.2))));
            if (err < 1)
            {
                return [x_, t_, h_];
            }
        }
        throw new Error();
    }
    
    // This function computes the derivative of U (a real 2N‐vector)
    // at time t. It uses finite differences with periodic BCs.
    function pde_rhs_dop853(U, params, t)
    {
        // Let N be half the length of U.
        N = U.length / 2;
        let dx = params.dx;
        // Reconstruct complex u from U (first N entries are real, next N are imag)
        let u_complex = new Array(N);
        for (let i = 0; i < N; i++)
        {
            u_complex[i] = math.complex(U[i], U[i + N]);
        }
        // Compute u_xx with periodic BCs.
        let u_xx = new Array(N);
        for (let i = 0; i < N; i++)
        {
            let ip = (i + 1) % N;
            let im = (i - 1 + N) % N;
            u_xx[i] = math.divide(math.add(math.subtract(u_complex[ip], math.multiply(2, u_complex[i])), u_complex[im]),dx * dx);
        }
        // Compute potential V(x) on our grid.
        V = pdeGrid.map(x => 0.5 * params.Omega_pde * params.Omega_pde * x * x +
                            params.A_pde * Math.pow(sech(params.b_pde * x), 2));
        // Compute rhs for each grid point.
        let rhs = new Array(N);
        for (let i = 0; i < N; i++)
        {
            // nonlinear term: |u|^2 * u
            let nonlinear = math.multiply(Math.pow(math.abs(u_complex[i]), 2), u_complex[i]);
            // inside = 0.5*u_xx + nonlinear - V(x)*u
            let inside = math.subtract(math.add(math.multiply(0.5, u_xx[i]), nonlinear),
                                       math.multiply(V[i], u_complex[i]));
            // Multiply by i (i.e., rotate by 90° in the complex plane)
            rhs[i] = math.multiply(math.complex(0, 1), inside);
        }
        // Return Udot as the concatenation of real and imag parts.
        let rhsReal = rhs.map(z => z.re);
        let rhsImag = rhs.map(z => z.im);
        return rhsReal.concat(rhsImag);
    }
    
    // Assume that SolveOde and dop853 are defined (or imported) per your attached code.
    function pdeStep_dop853(params)
    {
        // Here, U_pde is a global variable holding the current 2N-vector,
        // where N is the number of spatial points in pdeGrid.
        // Integrate the PDE from time currentTime to currentTime+dt.
        let startT = currentTime;
        let endT = currentTime + params.dt;
        let result = SolveOde(pde_rhs_dop853, dop853, params, startT, endT, params.dt, U_pde);
        // result[1] is the list of solution vectors; take the last one.
        U_pde = result[1][result[1].length - 1];
        // Reconstruct u (complex) from U_pde.
        N = U_pde.length / 2;
        u = new Array(N);
        for (let i = 0; i < N; i++)
        {
            u[i] = math.complex(U_pde[i], U_pde[i+N]);
        }
        currentTime = endT;
    }

    // Compute the PDE RHS for a given u array.
    function pde_rhs(u, params)
    {
        let rhs = new Array(N);
        let dx = params.dx;
        // Compute potential V(x) at grid points:
        V = pdeGrid.map(x => 0.5 * params.Omega_pde * params.Omega_pde * x * x + params.A_pde * Math.pow(sech(params.b_pde * x), 2));
        for (let i = 0; i < N; i++)
        {
            let ip = (i + 1) % N;
            let im = (i - 1 + N) % N;
            // Second derivative using central difference (periodic BC):
            let u_xx = math.divide(math.add(math.subtract(u[ip], math.multiply(2, u[i])), u[im]), dx * dx);
            let nonlinear = math.multiply(Math.pow(math.abs(u[i]), 2), u[i]);
            let potTerm = math.multiply(V[i], u[i]);
            let inside = math.subtract(math.add(math.multiply(0.5, u_xx), nonlinear), potTerm);
            // Multiply by i:
            rhs[i] = math.multiply(math.complex(0, 1), inside);
        }
        return rhs;
    }

    // RK4 step for PDE: returns new u array.
    function pdeRK4Step(u, dt, params)
    {
        let k1 = pde_rhs(u, params);
        let u2 = new Array(N);
        for (let i = 0; i < N; i++)
        {
            u2[i] = math.add(u[i], math.multiply(dt/2, k1[i]));
        }
        let k2 = pde_rhs(u2, params);
        let u3 = new Array(N);
        for (let i = 0; i < N; i++)
        {
            u3[i] = math.add(u[i], math.multiply(dt/2, k2[i]));
        }
        let k3 = pde_rhs(u3, params);
        let u4 = new Array(N);
        for (let i = 0; i < N; i++)
        {
            u4[i] = math.add(u[i], math.multiply(dt, k3[i]));
        }
        let k4 = pde_rhs(u4, params);
        let newU = new Array(N);
        for (let i = 0; i < N; i++)
        {
            newU[i] = math.add(u[i],
              math.multiply(dt/6,
                math.add(k1[i],
                  math.multiply(2, k2[i]),
                  math.multiply(2, k3[i]),
                  k4[i]
                )
              )
            );
        }
        return newU;
    }

    // The PDE step simply applies one RK4 time step.
    function pdeStep(params)
    {
        u = pdeRK4Step(u, params.dt, params);
    }

    // ----------------------- PDE Initialization -----------------------
    // Initialize the spatial grid and initial guess for u.
    // The initial ansatz is: u0(x) = A_sol * sech(A_sol*(x - x0)) * exp(i*v0*x)
    // (Optionally, one could refine this guess using Newton's method; here we assume the ansatz is acceptable.)
    function initPDE(params)
    {
        let {x_min, x_max, dx, x0, A_sol, v0} = params;
        N = Math.floor((x_max - x_min) / dx);
        pdeGrid = new Array(N);
        let applyNewtonToggleChecked = document.getElementById("applyNewtonToggle").checked;
        // Set initial condition for u:
        u = new Array(N);
        let U_init = new Float64Array(2 * params.N);
        
        let x = new Array(N);
        
        for (let i = 0; i < N; i++)
        {
            pdeGrid[i] = x_min + i * dx;
            let x_val = pdeGrid[i];
            let amplitude = params.A_sol * sech(params.A_sol * (x_val - x0));
            //let phase = v0 * x;
            u[i] = math.complex(amplitude, 0);

            if (applyNewtonToggleChecked)
            {
                U_init[i] = u[i].re;
                U_init[i + params.N] = u[i].im;
            }
           
            /*else
            {
                u[i] = math.complex(amplitude * Math.cos(phase), amplitude * Math.sin(phase));
            }*/
            x[i] = params.x_min + i * dx;
            
        }
        if (applyNewtonToggleChecked)
        {
            alert("Applying minimization now, please wait.");
            //[u, D2, x] = refineNewton(u, params);
            let V = pdeGrid.map(x => potentialForRefinement(x, params));
            let V_arr = new Float64Array(V);
            let U_ptr = Module._malloc(U_init.length * 8);
            let V_ptr = Module._malloc(V_arr.length * 8);
            Module.HEAPF64.set(U_init, U_ptr / 8);
            Module.HEAPF64.set(V_arr, V_ptr / 8);
            
            let resultPtr = refineCpp(U_ptr, V_ptr, params.N, params.dx, params.g, params.omega, window.useLM ? 1 : 0);
            let error = Module.ccall('getNLSResidual', 'number', [], []);
            alert("Residual error from C++ refinement 𝓕 = "+error);

            let resultData = Module.HEAPF64.slice(resultPtr / 8, resultPtr / 8 + 2 * params.N);
            u = new Array(params.N);
            for (let i = 0; i < params.N; i++)
            {
                u[i] = math.complex(resultData[i], resultData[i + params.N]);
                //console.log(`u[${i}] = ${u[i]}`);
            }

            // Cleanup
            Module._free(U_ptr);
            Module._free(V_ptr);
            //Module._free(resultPtr);
        }
        //tack on velocity afterwards
        for (let i = 0; i < N; i++)
        {
            let phase = v0 * x[i];
            u[i] = math.multiply(u[i], math.exp(math.complex(0, phase)));
        }
        U_pde = u.map(z => z.re).concat(u.map(z => z.im));
    }
    
    function potentialForRefinement(x, params)
    {
        return 0.5 * params.Omega_pde * params.Omega_pde * x * x + params.A_pde * Math.pow(sech(params.b_pde * x), 2);
    }
    
    // Helper functions for matrix concatenation:
    function hconcat(mat1, mat2)
    {
        if (mat1.length !== mat2.length)
        {
          throw "Matrices must have the same number of rows";
        }
        let res = [];
        for (let i = 0; i < mat1.length; i++)
        {
            res.push(mat1[i].concat(mat2[i]));
        }
        return res;
    }
    function vconcat(mat1, mat2)
    {
        return mat1.concat(mat2);
    }
    
    // --------------------------------------------------------------------
    // NEWTON REFINEMENT FUNCTION
    // It builds a local grid, computes the initial guess u0 = A_sol*sech(A_sol*(x - xStart))*exp(1j*c*x)
    // and then iterates a Newton method (with a full Jacobian using a finite-difference Laplacian matrix)
    // to refine U, which is a concatenation of real and imaginary parts.
    function refineNewtonHelper(u0, params, lr = 1)
    {
        // We'll override the initial u with our own ansatz on the refinement grid.
        let g = params.g;  // focusing NLS
        let L = params.x_min, R = params.x_max;
        let dx = params.dx;

        let x = new Array(N);
        for (let i = 0; i < N; i++)
        {
            x[i] = params.x_min + i * dx;
        }

        // Use c = 0 for the refinement since it's a steady-state problem
        let A_sol = params.A_sol
        let c = 0;
        // xStart from webpage: use params.x0.
        let xStart = params.x0;

        // U: concatenation of real and imaginary parts; will be an array of length 2N.
        let U = new Array(2 * N);
        for (let i = 0; i < N; i++)
        {
            //console.log(u0[i]);
            U[i] = u0[i].re;
            U[i + N] = u0[i].im;
        }

        // Compute potential V on the refinement grid.
        V = new Array(N);
        for (let i = 0; i < N; i++)
        {
            V[i] = potentialForRefinement(x[i], params);
        }
        //console.log("V =",V);
        let w_sol = params.omega;

        let err = Infinity;
        let max_iter = 100;
        let iter = 0;

        // Build the discrete Laplacian matrix D2 (NxN) with periodic boundaries.
        let D2 = numeric.rep([N, N], 0);
        for (let i = 0; i < N; i++)
        {
            D2[i][i] = -2;
            D2[i][(i+1)%N] = 1;
            D2[i][(i-1+N)%N] = 1;
        }
        D2 = numeric.mul(D2, 1/(dx*dx));
        //console.log("D2 =", D2);
        // Indices: first N entries for real parts, next N for imaginary parts.
        let indR_start = 0, indR_end = N;
        let indI_start = N, indI_end = 2*N;

        // Newton iteration.
        let U2 = new Array(N);
        let common_term = new Array(N);
        let Fr = new Array(N), Fi = new Array(N);
        let diagJ11 = new Array(N), diagJ22 = new Array(N), diagJ12 = new Array(N);

        while(err > tol && iter < max_iter)
        {
            // Extract Ur and Ui from U.
            let Ur = U.slice(indR_start, indR_end);
            let Ui = U.slice(indI_start, indI_end);
            //console.log("Ur =", Ur);
            //console.log("Ui =", Ui);
            // Compute modulus squared U2 = Ur^2 + Ui^2, elementwise.
            for (let i = 0; i < N; i++)
            {
                U2.push(Ur[i]*Ur[i] + Ui[i]*Ui[i]);
            }
            //console.log("U2 =",U2);
            // Compute common_term = g*U2 + V + w_sol.
            for (let i = 0; i < N; i++)
            {
                //console.log(`g=${g}, U2[${i}]=${U2[i]}, V[${i}]=${V[i]}, w_sol = ${w_sol}`);
                let r = Ur[i], im = Ui[i];
                U2[i] = r * r + im * im;
                common_term[i] = g * U2[i] + V[i] + w_sol;
            }
            //console.log("common_term =",common_term);
            // Compute residual F:
            // F_r = -0.5 * (D2 * Ur) + common_term .* Ur.
            // F_i = -0.5 * (D2 * Ui) + common_term .* Ui.
            let D2Ur = numeric.dot(D2, Ur);
            let D2Ui = numeric.dot(D2, Ui);
            //console.log("D2Ur =",D2Ur);
            //console.log("D2Ui =",D2Ui);
            for (let i = 0; i < N; i++)
            {
                Fr[i] = -0.5 * D2Ur[i] + common_term[i] * Ur[i];
                Fi[i] = -0.5 * D2Ui[i] + common_term[i] * Ui[i];
            }
            //console.log("Fr =",Fr);
            //console.log("Fi =",Fi);
            // F is concatenation of Fr and Fi.
            let F_vec = Fr.concat(Fi);
            //console.log("F_vec =", F_vec);
            err = numeric.norm2(F_vec);
            console.log("Newton iter:", iter, "err =", err);
            if(err < tol) break;
            // Build the Jacobian J (2N x 2N).
            for (let i = 0; i < N; i++)
            {
                // J11 = -0.5*D2 + diag( g*(3*Ur^2 + Ui^2) + V + w_sol )
                diagJ11[i] = g * (3 * Ur[i] * Ur[i] + Ui[i] * Ui[i]) + V[i] + w_sol;
                // J22 = -0.5*D2 + diag( g*(Ur^2 + 3*Ui^2) + V + w_sol )
                diagJ22[i] = g * (Ur[i] * Ur[i] + 3 * Ui[i] * Ui[i]) + V[i] + w_sol;
                // J12 = diag(2 * g * Ur * Ui)
                diagJ12[i] = 2 * g * Ur[i] * Ui[i];
            }
            let J11 = numeric.add(numeric.mul(D2, -0.5), numeric.diag(diagJ11));
            let J22 = numeric.add(numeric.mul(D2, -0.5), numeric.diag(diagJ22));
            let J12 = numeric.diag(diagJ12);
            // Assemble full Jacobian J as a block matrix:
            let top = hconcat(J11, J12);
            let bottom = hconcat(J12, J22);
            let J = vconcat(top, bottom);
            // Solve for Newton correction: J * DU = -F_vec.
            let DU = numeric.solve(J, numeric.neg(F_vec));
            // Update U: with learning rate lr=1.
            U = numeric.add(U, numeric.mul(lr, DU));
            iter += 1;
        }
        // Rebuild refined u from U: first N entries are real, next N are imaginary.
        let refined_u = new Array(N);
        for (let i = 0; i < N; i++)
        {
            refined_u[i] = math.complex(U[i], U[i + N]);
        }
        //console.log("Newton refinement completed in", iter, "iterations; final err =", err);
        return [refined_u, err, D2, x];
    }

    function refineNewton(u, params)
    {
        let lr = 1;
        let err = Infinity;
        let maxIter = 10;
        let iter = 0;
        let u0 = u.slice();
        //console.log("u0=",u0);
        progress = 0;
        do
        {
            console.log("lr=", lr);
            //params = getParameters()
            [u, err, D2, x] = refineNewtonHelper(u0.slice(), params, lr);
            iter += 1;
            lr *= 0.9;
        } while (err > tol && iter < maxIter);

        /*if (document.getElementById("applyAlertToggle").checked)
        {
            alert(`Newton done, error = ${err.toExponential(2)} ` + ((err <= tol) ? ' 🎉' : ' ❌') + "\n(press return to continue)" ) ;
        }*/
        if (err > tol)
        {
            alert(`Newton did not converge, error = ${err.toExponential(2)}. Returning starting ansatz.`);
            return [u0, D2, x];
        }
        progress = 100;
        // Hide the progress bar once Newton is done
        // window.document.getElementById("newtonProgressContainer").style.display = "none";
       // window.document.getElementById("newtonProgressBar").outerHTML =
        //String.raw`
        //<div id="newtonProgressBar" class="progress-bar" role="progressbar" style="width: ${progress}%;" aria-valuenow="${progress}" aria-valuemin="0" aria-valuemax="100"></div>
        //`
        
        return [u, D2, x];
    }

    // ----------------------- Plotly Initialization & Update -----------------------
    function initPlots(params)
    {
        // ODE plot: potential and particle marker.
        let odePotential = pdeGrid.map(x => 0.5 * params.Omega * params.Omega * x * x + params.A * Math.pow(sech(params.b * x), 2));
        let initialODEPotential = 0.5 * params.Omega * params.Omega * params.x0 * params.x0 + params.A * Math.pow(sech(params.b * params.x0), 2);

        let odeTracePotential =
        {
            x: pdeGrid,
            y: odePotential,
            mode: 'lines',
            name: 'ODE Potential: '+'$V(x) = \\frac{1}{2}\\Omega^2 + A\\cdot\\text{sech}^2(bx)$'
        };
        let odeTraceParticle =
        {
            x: [params.x0],
            y: [initialODEPotential],
            mode: 'markers',
            marker: { size: 12, color: 'red' },
            name: 'Particle'
        };
        let odeLayout =
        {
            title: 'ODE: Particle in Potential',
            xaxis: { title: 'x' },
            yaxis: { title: 'Potential Energy' },
            annotations:
            [{
                xref: 'paper', yref: 'paper', x: 0.05, y: 0.95,
                text: 'Time: 0.00', showarrow: false, font: { size: 16 }
            }]
        };
        Plotly.newPlot('odePlot', [odeTracePotential, odeTraceParticle], odeLayout);
        // PDE plot: potential and soliton density.
        pdePotential = pdeGrid.map(x => 0.5 * params.Omega_pde * params.Omega_pde * x * x + params.A_pde * Math.pow(sech(params.b_pde * x), 2));
        // --- grab ψ (length 2N doubles) from WASM -----------------------
//        const ptrPsi   = getPsiPointer();
//        const psiView  = new Float64Array(Module.HEAPF64.buffer, ptrPsi, 2*params.N);

        // build |u|² on the fly
        const density = new Array(params.N).fill(0);
        /*for (let i = 0; i < params.N; ++i)
        {
            const Re = psiView[2*i];
            const Im = psiView[2*i + 1];
            density[i] = Re*Re + Im*Im;
            
        }*/
        //console.log("u=",u);
        //console.log("pdeGrid=",pdeGrid);
        //let density = pdeGrid.map((x, i) => math.abs(u[i]) ** 2);
        let pdeTracePotential =
        {
            x: pdeGrid,
            y: pdePotential,
            mode: 'lines',
            name: 'PDE Potential'+'$V(x) = \\frac{1}{2}\\Omega_{\\text{pde}}^2 + A_{\\text{pde}}\\cdot\\text{sech}^2(b_{\\text{pde}}x)$'
        };
        let pdeTraceDensity =
        {
            x: pdeGrid,
            y: density,
            mode: 'lines',
            name: 'Soliton Density $$|u|^2$$'
        };
        let pdeLayout =
        {
            title: 'PDE: Soliton in Potential',
            xaxis: { title: 'x' },
            yaxis: { title: 'Energy / Density' },
            annotations:
            [{
                xref: 'paper', yref: 'paper', x: 0.05, y: 0.95,
                text: 'Time: 0.00', showarrow: false, font: { size: 16 }
            }]
        };
        Plotly.newPlot('pdePlot', [pdeTracePotential, pdeTraceDensity], pdeLayout);
    }

    function updatePlots(params, replotOdePotential = false)
    {
        // Update ODE particle position:
        let currentODEPotential = 0.5 * params.Omega * params.Omega * odeState.x * odeState.x + params.A * Math.pow(sech(params.b * odeState.x), 2);
        if (replotOdePotential)
        {
            let odePotential = pdeGrid.map(x => 0.5 * params.Omega * params.Omega * x * x + params.A * Math.pow(sech(params.b * x), 2));

            let odeTracePotential =
            {
                x: pdeGrid,
                y: odePotential,
                mode: 'lines',
                name: 'ODE Potential: '+'$V(x) = \\frac{1}{2}\\Omega^2 + A\\cdot\\text{sech}^2(bx)$'
            };
            let odeTraceParticle =
            {
                x: [odeState.x],
                y: [currentODEPotential],
                mode: 'markers',
                marker: { size: 12, color: 'red' },
                name: 'Particle'
            };
            let odeLayout =
            {
                title: 'ODE: Particle in Potential',
                xaxis: { title: 'x' },
                yaxis: { title: 'Potential Energy' },
                annotations:
                [{
                    xref: 'paper', yref: 'paper', x: 0.05, y: 0.95,
                    text: ('Time: ' + currentTime.toFixed(2)), showarrow: false, font: { size: 16 }
                }]
            };
            Plotly.newPlot('odePlot', [odeTracePotential, odeTraceParticle], odeLayout);
        }
        else
        {
            Plotly.update('odePlot',
            {
                x: [[odeState.x]],
                y: [[currentODEPotential]]
            }, {}, [1]);
            Plotly.relayout('odePlot', {'annotations[0].text': 'Time: ' + currentTime.toFixed(2)});
        }
        // Update PDE density:
        pdePotential = pdeGrid.map(x => 0.5 * params.Omega_pde * params.Omega_pde * x * x + params.A_pde * Math.pow(sech(params.b_pde * x), 2));
        //let density = pdeGrid.map((x, i) => math.abs(u[i]) ** 2);
        // --- grab ψ (length 2N doubles) from WASM -----------------------

        // build |u|² on the fly
        const density = new Array(params.N);
        for (let i = 0; i < params.N; ++i)
        {
            const Re = u[i];
            const Im = u[N + i];
            density[i] = Re*Re + Im*Im;
        }
        let pdeTracePotential =
        {
            x: pdeGrid,
            y: pdePotential,
            mode: 'lines',
            name: 'PDE Potential'+'$V(x) = \\frac{1}{2}\\Omega_{\\text{pde}}^2 + A_{\\text{pde}}\\cdot\\text{sech}^2(b_{\\text{pde}}x)$'
        };
        let pdeTraceDensity =
        {
            x: pdeGrid,
            y: density,
            mode: 'lines',
            name: 'Soliton Density $$|u|^2$$'
        };
        let pdeLayout =
        {
            title: 'PDE: Soliton in Potential',
            xaxis: { title: 'x' },
            yaxis: { title: 'Energy / Density' },
            annotations:
            [{
                xref: 'paper', yref: 'paper', x: 0.05, y: 0.95,
                text: `Time: ${currentTime.toFixed(2)}`, showarrow: false, font: { size: 16 }
            }]
        };
        Plotly.newPlot('pdePlot', [pdeTracePotential, pdeTraceDensity], pdeLayout);
    }

    // ----------------------- Simulation Initialization & Loop -----------------------
    function initSimulations()
    {
        const params = getParameters();
        console.log(`setSimParameters called with ${params.dt} ${params.T} ${params.N} ${params.m} ${params.Omega} ${params.A} ${params.b} ${params.x0} ${params.v0} ${params.dx} ${params.Omega_pde} ${params.A_pde} ${params.b_pde}`)
        currentTime = 0;
        setCurrentTime(0);
        // Initialize ODE state:
        odeState = { x: params.x0, v: params.v0 };
        // Initialize PDE grid and initial condition:
        initPDE(params);
        setSimParameters(params.dt, params.T, params.N, params.m, params.Omega, params.A, params.b, params.x0, params.v0, params.dx, params.x_min, params.x_max, params.Omega_pde, params.A_pde, params.b_pde, params.A_sol);
        initPlots(params);
    }

    function simulationStep()
    {
        let params = getParameters();
        // Update ODE state with RK4:
        //odeState = rk4Step(odeState.x, odeState.v, params.dt, params);
        //currentTime += params.dt;
        // Update PDE using our RK4 integrator:
        //console.log("u=",u);
        //pdeStep(params);
        //pdeStep_dop853(params);
        if (currentTime >= params.T)
        {
            clearInterval(simInterval);
            simulationRunning = false;
            if (document.getElementById("loopToggle").checked)
            {
                setTimeout(() =>
                {
                    freePsi();
                    initSimulations();
                    let params = getParameters();
                    let plotEveryMs = parseInt(document.getElementById("stepsPerUpdate").value); //WA
                    simInterval = setInterval(() =>
                    {
                        plotEveryMs = parseInt(document.getElementById("stepsPerUpdate").value);
                        stepForPlotInterval(plotEveryMs);
                        const ptrPsi   = getPsiPointer();
                        u  = new Float64Array(Module.HEAPF64.buffer, ptrPsi, 2*params.N);
                        odeState.x = getXParticle();        // fresh position
                        odeState.v = getVParticle();        // fresh velocity
                        currentTime = getCurrentTime();     // C++ clock
                        simulationStep();
                        updatePlots(params); // update both plots right after stepping
                    }, plotEveryMs);
                    simulationRunning = true;
                }, 0);
            }
        }
    }
    
    // sleep time expects milliseconds
    function sleep (time)
    {
        return new Promise((resolve) => setTimeout(resolve, time));
    }
    
    const conj = (z) => ({ re: z.re, im: -z.im });
    const add = (z1, z2) => ({ re: z1.re + z2.re, im: z1.im + z2.im });
    
    // This function assumes that you already have computed the steady state u, D2, and the potential V as arrays.
    // Also assume that your parameters object `params` contains:
    // - g         (nonlinearity coefficient)
    // - wfreq     (the steady-state frequency)
    // - D2        (the finite difference Laplacian matrix)
    // - V         (the potential vector evaluated on the grid)
    // - u         (the steady state solution, as an array of length N with complex numbers from math.js)
    // - N         (the number of grid points)
    function computeEigenspectrum(params)
    {
        N = params.N;
        let g = params.g;
        const wfreq = params.wfreq;
        const D2 = params.D2;  // D2 should be an N x N numeric.js matrix
        console.log("D2 =",D2);
        //console.log("V =",V);
        V = params.V;    // V is an array of length N
        u = params.u;    // u is an array of N math.js complex numbers
        //console.log("V =",V);
        // Build the diagonal matrices.
        // In MATLAB, the matrices M11 and M12 are defined as:
        //   M11 = -(-0.5*D2+diag(2*g*u.*conj(u)+V+wfreq));
        //   M12 = -diag(g*u.*u);
        //   M21 = -conj(M12);
        //   M22 = -conj(M11);
        // and then M = 1i * [M11, M12; M21, M22].
        // In JavaScript we build these blocks as arrays.
      
        // Precompute |u|^2, and u^2.
        let abs2 = u.map(z => math.add(math.multiply(z.re, z.re), math.multiply(z.im, z.im)));
        //console.log("abs2 =",abs2);
        let uSquared = u.map(z => math.square(z).re);  // returns a math.js Complex
        //console.log("uSquared =",uSquared);
        let two_g_abs2 = abs2.map(val => 2 * g * val);
        //console.log("two_g_abs2 =",two_g_abs2);
        let diagM11 = [];
        let diagM12 = [];

        // For each i = 0,...,N-1:
        for (let i = 0; i < N; i++)
        {
            // M11 diagonal entry is 2*g|u_i|^2 + V(i) + wfreq.
            diagM11.push(two_g_abs2[i] + V[i] + wfreq);
            // M12 diagonal entry is g*u_i^2.
            // We will construct these as complex numbers.
            diagM12.push(-math.multiply(g, uSquared[i]));
        }
        //console.log("diagM11 =",diagM11);
      
        // Build block matrices with D2.
        // We define A = -0.5*D2 + diag(diagM11) and B = -diag(diagM12)
        // (Note the double negation in the MATLAB code).
        let A = numeric.neg(numeric.add(numeric.mul(D2, -0.5), numeric.diag(diagM11)));  // Because MATLAB: M11 = -(-0.5*D2+diag(...))
        //console.log("A =",A);
        // For B, we need a diagonal matrix whose diagonal entries are diagM12, but with a minus sign.
        let B = numeric.diag(diagM12);
        //console.log("B =",B);

        // For M21 and M22, we have:
        // M21 = -conj(M12)   and   M22 = -conj(M11)
        // So M21 is the conjugate of B:
        let B_conj = numeric.diag(diagM12.map(x => math.unaryMinus(math.conj(x))));
        //console.log("B_conj = ",B_conj);
        // And M22 is:
        let A_conj = numeric.add(numeric.mul(D2, -0.5), numeric.diag(diagM11.map(x => x))); // conj of diag is itself (if real)
        //console.log("A_conj = ",A_conj);

        // Now build the full 2N x 2N matrix M.
        // M = 1i * [A, B; B_conj, A_conj].
        let topRow = A.map((row, idx) => row.concat(B[idx]));
        let bottomRow = A_conj.map((row, idx) => B_conj[idx].concat(row));
        let fullMatrix = topRow.concat(bottomRow);
        // Multiply fullMatrix by 1i.
        fullMatrix = fullMatrix.map(row => row.map(val => math.multiply(math.complex(0, 1), val)));
        //console.log("fullMatrix =",fullMatrix);
        // Now compute eigenvalues and eigenvectors using math.eigs.
        // math.eigs() accepts a numeric.js matrix or a plain array.
        let eigResult;

        if (!window.loadedCPPFunctions) {
            alert("C++ module not ready yet!");
            return;
        }

        const Module = window.Module;
        const computeEigenspectrumCpp = window.computeEigenspectrumCpp;

        let flattened = new Float64Array(2 * N * N);
        for (let i = 0; i < N; i++) {
            for (let j = 0; j < N; j++) {
                let z = fullMatrix[i][j];
                let idx = 2 * (i * N + j);
                flattened[idx] = z.re;
                flattened[idx + 1] = z.im;
            }
        }

        // Allocate in heap
        let ptr = Module._malloc(flattened.length * 8); // allocates memory in WebAssembly for `flattened` (Float64Array), with each element requiring 8 bytes
        if (!ptr) throw new Error("Memory allocation failed");
        console.log("HEAP size (MB):", Module.HEAPU8.length / (1024 * 1024));
        Module.HEAPF64.set(flattened, ptr / 8); //sets the values from `flattened` (a Float64Array) into WebAssembly memory at the index `ptr / 8` in HEAPF64, corresponding to byte address `ptr`
        console.log("HEAP size (MB):", Module.HEAPU8.length / (1024 * 1024));
        console.log("N = ", N);
        // Call C++ function
        let resultPtr = computeEigenspectrumCpp(ptr, N);
        if (resultPtr === 0)
        {
            alert("Eigenvalue decomposition failed");
            Module._free(ptr);
            return;
        }

        // Total number of doubles returned: 2*N (eigenvalues) + 2*N*N (eigenvectors)
        const resultData = Module.HEAPF64.slice(resultPtr / 8, resultPtr / 8 + 2 * N + 2 * N * N);
        // Extract eigenvalues
        let eigenvalues = new Array(N);
        for (let i = 0; i < N; i++) {
          eigenvalues[i] = { re: resultData[2 * i], im: resultData[2 * i + 1] };
        }

        // ✅ Preallocate eigenvector array: eigenvectors[j][i] = ith component of jth eigenvector
        const eigenvectors = new Array(N);
        
        // ✅ Fill eigenvectors efficiently — NO math.complex, NO console.log
        for (let j = 0; j < N; j++)
        {
            eigenvectors[j] = new Array(N);
            for (let i = 0; i < N; i++)
            {
                const idx = 2 * N + 2 * (j * N + i);
                eigenvectors[j][i] = { re: resultData[idx], im: resultData[idx + 1] };
            }
        }

        // ✅ Clean up memory
        Module._free(ptr);
        Module._free(resultPtr);
        
        // numeric.js
        if (window.useNumericJs)
        {
            try {
                eigResult = math.eigs(fullMatrix);
            } catch (err) {
            console.warn("Eigenvalue computation did not fully converge; using partial results.");
            eigResult = {
                values: err.values,
                vectors: err.vectors
                };
            }
        }
        
        else
        {
            try {
                eigResult = {
                    values: eigenvalues,
                    vectors: eigenvectors
                    };
            } catch (err) {
                console.warn("Eigenvalue computation did not fully converge...");
                return;
            }
        }
        
        console.log("eigResult =",eigResult);
        
        // eigResult.values is an array of complex numbers
        // eigResult.vectors is a 2N x 2N matrix where each column is an eigenvector.
        // Determine the effective number of eigenpairs by taking the minimum length:
        let numValues = eigResult.values.length;
        console.log("numValues=",numValues);
        let numVecs = eigResult.vectors.length;
        console.log("numVecs=",numVecs);
        let numValid = Math.min(numValues, numVecs);
        if (numValid < numValues) {
            console.warn(`Mismatch: ${numValues} eigenvalues but only ${numVecs} eigenvectors. Using first ${numValid} pairs.`);
        }

        if (window.useNumericJs)
        {
            // Build an array of indices 0,..., numValid-1 and sort them by descending real part:
            let indices = Array.from({length: numValid}, (_, i) => i);
            indices.sort((i, j) => eigResult.values[j].re - eigResult.values[i].re);
            console.log("indices =", indices);

            // Sorted eigenvalues:
            let sortedVals = indices.map(i => eigResult.values[i]);
            console.log("sortedVals =", sortedVals);

            // For eigenvectors, assume each eigenvector is an object with a property "vector" representing the eigenvector.
            // If some eigenvector is missing, we can substitute an array of zeros.
            let vecs = eigResult.vectors;
            //console.log("vecs[0]=",vecs[0])
            let sortedVecs = indices.map(i => {
                if (vecs[i]) {
                    return vecs[i];
                }
                else {
                    console.warn(`No eigenvector available for index ${i}; substituting zero vector.`);
                    return new Array(N).fill(math.complex(0,0));
                }
            });
            console.log("sortedVecs =", sortedVecs);

            // Combine eigenvector components if desired; for instance, combining the first half and conjugate of the second half.
            let modeVecs = sortedVecs.map(vec => {
                let firstHalf = vec.slice(0, N);
                let secondHalf = vec.slice(N, 2 * N);
                // Combine as: combined = firstHalf + conj(secondHalf)
                let combined = firstHalf.map((val, idx) =>
                  add(val, conj(secondHalf[idx]))
                );
                return combined;
            });

            try
            {
                console.log("sortedVals.length =",sortedVals.length);
                console.log("eigResult.values.length =",eigResult.values.length);
                console.log("sortedVecs.length =",sortedVecs.length);
                console.log("eigResult.vectors.length =",eigResult.vectors.length);
            }
            catch (err)
            {
                console.log(`Error when printing, ${err}`);
            }
        }
      
        let returnVal = {eigenvalues: eigResult.values, eigenmodes: eigResult.vectors};
        if (window.useNumericJs)
        {
            if (sortedVals !== undefined && eigResult !== undefined && eigResult.values !== undefined)
            {
                returnVal.eigenvalues = ((sortedVals.length >= eigResult.values.length) ? sortedVals : eigResult.values);
            }
            if (sortedVecs !== undefined && eigResult !== undefined && eigResult.vectors !== undefined)
            {
                returnVal.eigenmodes = ((sortedVecs.length >= eigResult.vectors.length) ? modeVecs : eigResult.vectors);
            }
        }
        N = params.N; // reset N jic
        return returnVal;
    }

    // Example of using the function:
    // Assume params is built from getParameters() and that you have computed u, D2, V, N, g, wfreq as appropriate.
    document.getElementById("computeSpectrumBtn").addEventListener("click", function()
    {
        let params = getParameters();
        let {x_min, x_max, dx, x0, A_sol, v0} = params;
        params.N = Math.floor((x_max - x_min) / dx);
        N = params.N;
        params.g = -1;
        params.wfreq = params.Omega;
        let x_val;
        let x = new Array(N);
        u = new Array(N);
        let U_init = new Float64Array(2 * N);
        pdeGrid = new Array(N);
        for (let i = 0; i < params.N; i++)
        {
            pdeGrid[i] = x_min + i * dx;
            x_val = pdeGrid[i];
            let amplitude = A_sol * sech(A_sol * (x_val - x0));
            //let phase = v0 * x;
            u[i] = math.complex(amplitude, 0);
            //console.log("u[",i,"] = ", u[i], ", x[",i,"] = ", x_val, ", dx = ",dx);
            x[i] = x_min + i * dx;
            U_init[i] = u[i].re;
            U_init[i + params.N] = u[i].im;
        }
      
        //[params.u, params.D2, x] = refineNewton(u, params);
        //[u, D2, x] = refineNewton(u, params);
        let V = pdeGrid.map(x => potentialForRefinement(x, params));
        let V_arr = new Float64Array(V);
        let U_ptr = Module._malloc(U_init.length * 8);
        let V_ptr = Module._malloc(V_arr.length * 8);
        Module.HEAPF64.set(U_init, U_ptr / 8);
        Module.HEAPF64.set(V_arr, V_ptr / 8);
        
        let resultPtr = refineCpp(U_ptr, V_ptr, params.N, params.dx, params.g, params.omega, window.useLM ? 1 : 0);
        let error = Module.ccall('getNLSResidual', 'number', [], []);
        alert("Residual error from C++ refinement 𝓕 = " + error);

        let resultData = Module.HEAPF64.slice(resultPtr / 8, resultPtr / 8 + 2 * params.N);
        params.u = new Array(params.N);
        params.D2 = numeric.rep([N, N], 0);

        for (let i = 0; i < params.N; i++)
        {
            params.u[i] = math.complex(resultData[i], resultData[i + params.N]);
            params.D2[i][i] = -2;
            params.D2[i][(i+1)%N] = 1;
            params.D2[i][(i-1+N)%N] = 1;
            //console.log(`u[${i}] = ${params.u[i]}`);
        }
        params.D2 = numeric.mul(params.D2, 1/(dx*dx));

        // Cleanup
        Module._free(U_ptr);
        Module._free(V_ptr);
        Module._free(resultPtr);
        
        params.V = new Array(N);
        for (let i = 0; i < N; i++)
        {
            params.V[i] = potentialForRefinement(x[i], params);
        }

        console.log("u = ", params.u, ", D2 = ", params.D2);
        spectrum = computeEigenspectrum(params);
        console.log("Eigenvalues:", spectrum.eigenvalues);
        console.log("Eigenmodes:", spectrum.eigenmodes);

        // Plot the eigenvalues (Re vs Im) on the left.
        let eigenvalueTrace =
        {
            x: spectrum.eigenvalues.map(z => z.re),
            y: spectrum.eigenvalues.map(z => z.im),
            mode: 'markers',
            marker: { size: 8 },
            name: 'Eigenvalues'
        };
        let eigenvalueLayout =
        {
            title: 'Eigenvalue Spectrum',
            xaxis: { title: 'Re(λ)' },
            yaxis: { title: 'Im(λ)' }
        };
        
        if (window.useNumericJs)
        {
            document.getElementById("eigenvaluePlot").innerHTML = `<b style='color:red'>${spectrum.eigenvalues.length} eigenvalues and ${spectrum.eigenmodes.length} eigenvectors found</b> (<a href="https://www.npmjs.com/package/numeric" target="_blank">Numeric JS</a> sucks btw)`;
        }
        else
        {
            document.getElementById("eigenvaluePlot").innerHTML = `<b style='color:blue'>${spectrum.eigenvalues.length} eigenvalues and ${spectrum.eigenmodes.length} eigenvectors found</b> (<a href="https://eigen.tuxfamily.org/" target="_blank">C++ Eigen</a> <a href="https://emscripten.org/docs/porting/connecting_cpp_and_javascript/index.html" target="_blank">Emscripten</a> ftw)`;
            const residual = Module.ccall('getLastResidual', 'number', [], []);
            document.getElementById("eigenvaluePlot").innerHTML +=
              '$$\\text{Max residual: }\\|Av - \\lambda v\\| ='+`${toLatexExp(residual, 2)}`+"$$";
            // Force MathJax to reprocess math in the page
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, "eigenvaluePlot"]);
        }
        Plotly.newPlot('eigenvaluePlot', [eigenvalueTrace], eigenvalueLayout);

        // Set the global variable and plot the first eigenmode:
        currentEigenMode = 0;
        document.getElementById("stabilityPlots").style.display = "block";
        updateEigenmodePlot(params);
    });
    function clearPlots()
    {
        //pdePlot = document.getElementById("pdePlot");
        //odePlot = document.getElementById("odePlot");
        
        
        Plotly.newPlot('pdePlot', [[], []]);
        Plotly.newPlot('odePlot', [[], []]);

    }


    /* --------------- new global flags ------------------- */
    let paused             = false;   // true ↔ simulation paused but state kept
    let savedFieldPtr      = null;    // pointer to ψ in WASM when paused
    let savedParticleState = null;    // {x , v}

    /* --------------- helper: (re)arm JS ↔ C++ coupling -- */
    function resumeCppLoop(plotEveryMs)
    {
        /* kick the C++ side as fast as it can for ≤ plotEveryMs ms
           then ship back the new buffers & update the plots          */
        const params   = getParameters();
        simInterval = setInterval(() =>
        {
            plotEveryMs = +document.getElementById("stepsPerUpdate").value;
            stepForPlotInterval(plotEveryMs);           // C++ crunch

            /* ----- pull fresh state out of WASM -------------------- */
            const ptrPsi   = getPsiPointer();
            u              = new Float64Array(Module.HEAPF64.buffer,
                                              ptrPsi, 2*params.N);
            odeState.x     = getXParticle();
            odeState.v     = getVParticle();
            currentTime    = getCurrentTime();

            updatePlots(params, true);
            simulationStep();                           // auto-loop logic
        }, plotEveryMs);
    }
    
    function atEnd()
    {
        
        let at_end = (currentTime >= parseFloat(document.getElementById("T").value));
        return at_end;
    }

    /* --------------- Start button ----------------------- */
    document.getElementById("startBtn").addEventListener("click", () =>
    {
        if (simulationRunning || atEnd()) return;          // already running
        const params = getParameters();

        /* ───────── CASE 1 : resume after pause ───────── */
        if (paused)
        {
            paused = false;
            const sameGrid = (params.N === N);          // N is global

            if (!sameGrid)
            {
                if (!confirm("Grid size changed – restart from t = 0 ?"))
                    return;                             // user aborted

                /* full restart */
                freePsi();                              // C++
                initSimulations();                      // JS (t = 0)
            }
            else
            {
                /* just refresh scalar parameters, keep ψ & particle */
                setSimParameters(
                    params.dt, params.T, params.N,
                    params.m, params.Omega,
                    params.A, params.b,
                    odeState.x, odeState.v,          // keep current centre & velocity
                    params.dx, params.x_min, params.x_max,
                    params.Omega_pde, params.A_pde, params.b_pde,
                    params.A_sol
                );

            }
            resumeCppLoop(params.stepsPerUpdate);
            simulationRunning = true;
            paused            = false;
            return;
        }
        /* ───────── CASE 2 : completely fresh run ─────── */
        console.log("restart");
        freePsi();
        initSimulations();
        resumeCppLoop(params.stepsPerUpdate);
        simulationRunning = true;
    });

    /* --------------- Stop button ----------------------- */
    document.getElementById("stopBtn").addEventListener("click", () =>
    {
        if (paused || !simulationRunning) //If the simulation is paused or not running, return.
        {
            //paused = true;
            //simulationRunning = false;
            return;
        }

        clearInterval(simInterval);
        simulationRunning = false;
        paused            = true;

        const p = getParameters();
        odeState    = {x: getXParticle(), v: getVParticle()};

        /* re-init u in-place */
        setSimParameters(
            p.dt, p.T, p.N,
            p.m, p.Omega,
            p.A, p.b,
            p.x0, p.v0,
            p.dx, p.x_min, p.x_max,
            p.Omega_pde, p.A_pde, p.b_pde,
            p.A_sol
        );
        updatePlots(p, true);    // redraw potentials
    });

    /* ------------------ Reset button ---------------- */
    /* Frees ψ, clears plots, and leaves everything idle */
    document.getElementById("resetBtn").addEventListener("click", function()
    {
        /* 1. stop timers if they’re still running */
        clearInterval(simInterval);
        simulationRunning = false;
        paused = false;
        
        /* 2. free the big buffer on the C++ side */
        freePsi();

        /* 3. clear JS-side state / plots */
        odeState = null;
        currentTime = 0;
        setCurrentTime(0);
        clearPlots();   //TODO Change with initplots but don't do Newton.
    });

    window.addEventListener("resize", function()
    {
        Plotly.Plots.resize(document.getElementById("odePlot"));
        Plotly.Plots.resize(document.getElementById("pdePlot"));
    });
    
    </script>

    <!-- Bootstrap JS and dependencies -->
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
  </body>
</html>
