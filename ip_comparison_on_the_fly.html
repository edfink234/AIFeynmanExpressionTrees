<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <script src="https://cdn.jsdelivr.net/npm/plotly.js@2.10.0/dist/plotly.min.js"></script>
    <title>Interactive Inverted Pendulum Solver</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 20px;
            color: #333;
        }

        h1 {
            text-align: center;
            color: #444;
        }

        .control-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        .control-container label {
            width: 60px; /* Set a fixed width for labels to ensure alignment */
            text-align: right;
            margin-right: 10px;
        }

        .control-container input[type="number"] {
            width: 60px; /* Set a fixed width for number inputs */
            margin-right: -25px;
        }

        .control-label {
            font-weight: bold;
            margin-right: 10px;
        }

        .arrow {
            cursor: pointer;
            font-size: 20px;
            color: #555;
            margin: 0 10px;
            user-select: none; /* Prevent text selection */
            border: 2px solid transparent; /* Prevent focus outline */
            border-radius: 5px;
            padding: 5px 10px;
            transition: background-color 0.3s, color 0.3s;
        }

        .arrow:hover {
            background-color: #007BFF;
            color: white;
        }

        .arrow:active {
            transform: scale(0.9);
        }

        .slider {
            -webkit-appearance: none;
            appearance: none;
            width: 200px;
            height: 8px;
            background: #ddd;
            border-radius: 5px;
            outline: none;
            transition: background 0.3s;
            margin: 0 10px; /* Add space around the slider */
        }

        .slider:hover {
            background: #ccc;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #007BFF;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }

        .slider::-webkit-slider-thumb:hover {
            background: #0056b3;
        }

        .slider::-webkit-slider-thumb:active {
            transform: scale(1.2);
        }
        .plot-container {
            margin-top: 40px;
        }
        
        input[type="number"] {
            width: 60px;
            margin: 0px 0px 0px 20px;
        }
        
        label {

            margin: 0px 20px 0px 20px;
        }
        
        :root {
                --background-color: #ffffff;
                --text-color: #333333;
                --plot-bg-color: #ffffff;
                --plot-grid-color: #dddddd;
            }

            body {
                background-color: var(--background-color);
                color: var(--text-color);
            }

            .plot-container {
                background-color: var(--plot-bg-color);
            }
        
    </style>
</head>
<body>
    <h1>Interactive Inverted Pendulum Viewer</h1>
    <div class="latex-equation">
        $$\begin{align*}
        &\text{Original Horizontal about $\theta=\pi$: } \quad \ddot{\theta} + \frac{g}{l} \sin (\theta) =  \frac{ A \omega^2}{l} \left( \cos (\theta) \cos(\omega t) \right) - \lambda \dot{\theta} \\
        &\text{Second-Order Horizontal about $\theta=\pi$: }\quad  \ddot{\theta} + \frac{g}{l}\left((\pi - \theta) + \frac{(\theta - \pi)^3}{6}\right) =  \frac{ A \omega^2}{l}\left(-1 + \frac{(\theta-\pi)^2}{2}\right)\cos(\omega t) - \lambda \dot{\theta} \\
        &\text{Original Vertical about $\theta=\pi$: } \quad \ddot{\theta} + \frac{g}{l} \sin (\theta) = -\frac{A \omega^2}{l} \left( \sin (\theta) \cos(\omega t) \right) - \lambda \dot{\theta} \\
        &\text{Second-Order Vertical about $\theta=\pi$: } \quad \ddot{\theta} + \frac{g}{l} \left((\pi - \theta) + \dfrac{(\theta - \pi)^3}{6}\right) = -\frac{A \omega^2}{l} \left( \left((\pi - \theta) + \dfrac{(\theta - \pi)^3}{6}\right) \cos(\omega t) \right)  - \lambda \dot{\theta}
        \end{align*}$$
    </div>
    <br>
    <div class="container">
        <div class="row mx-3">
            <div class="col-md">
                <label for="minA">\(A_{\text{min}}\):</label>
            </div>
            <div class="col-md">
                <input type="number" id="minA" step="0.01" value="0">
            </div>
            <div class="col-md">
                <label class="control-label">\(A\):</label>
            </div>
            <div class="col-md">
                <input id="A-slider" type="range" min="0" max="10" step="0.01" value="1" class="slider">
            </div>
            <div class="col-md">
                <input type="number" id="A-input" step="0.01" value="1" style="width: 80px;">
            </div>
            <div class="col-md">
                <label for="maxA">\(A_{\text{max}}\):</label>
            </div>
            <div class="col-md">
                <input type="number" id="maxA" step="0.01" value="10">
            </div>
        </div>
        
        <div class="row mx-3">
            <div class="col-md">
                <label for="minOmega">\(\omega_{\text{min}}\):</label>
            </div>
            <div class="col-md">
                <input type="number" id="minOmega" step="0.01" value="0">
            </div>
            <div class="col-md">
                <label class="control-label">\(\omega\):</label>
            </div>
            <div class="col-md">
                <input id="omega-slider" type="range" min="0" max="10" step="0.01" value="1" class="slider">
            </div>
            <div class="col-md">
                <input type="number" id="omega-input" step="0.01" value="1" style="width: 80px;">
            </div>
            <div class="col-md">
                <label for="maxOmega">\(\omega_{\text{max}}\):</label>
            </div>
            <div class="col-md">
                <input type="number" id="maxOmega" step="0.01" value="10">
            </div>
        </div>

        <div class="row mx-3">
            <div class="col-md">
                <label for="minL">\(l_{\text{min}}\):</label>
            </div>
            <div class="col-md">
                <input type="number" id="minL" step="0.01" value="0">
            </div>
            <div class="col-md">
                <label class="control-label">\(l\):</label>
            </div>
            <div class="col-md">
                <input id="l-slider" type="range" min="0" max="10" step="0.01" value="1" class="slider">
            </div>
            <div class="col-md">
                <input type="number" id="l-input" step="0.01" value="1" style="width: 80px;">
            </div>
            <div class="col-md">
                <label for="maxL">\(l_{\text{max}}\):</label>
            </div>
            <div class="col-md">
                <input type="number" id="maxL" step="0.01" value="10">
            </div>
        </div>

        <div class="row mx-3">
            <div class="col-md">
                <label for="minTheta0">\(\theta_{0_{\text{min}}}\):</label>
            </div>
            <div class="col-md">
                <input type="number" id="minTheta0" step="0.01" value="2.8">
            </div>
            <div class="col-md">
                <label class="control-label">\(\theta_0\):</label>
            </div>
            <div class="col-md">
                <input id="theta-slider" type="range" min="2.8" max="3.4" step="0.01" value="3.0" class="slider">
            </div>
            <div class="col-md">
                <input type="number" id="theta-input" step="0.01" value="3" style="width: 80px;">
            </div>
            <div class="col-md">
                <label for="maxTheta0">\(\theta_{0_{\text{max}}}\):</label>
            </div>
            <div class="col-md">
                <input type="number" id="maxTheta0" step="0.01" value="3.4">
            </div>
        </div>
        <div class="row mx-3">
            <div class="col-md">
                <label for="minLambda">\(\lambda_{\text{min}}\):</label>
            </div>
            <div class="col-md">
                <input type="number" id="minLambda" step="0.01" value="0">
            </div>
            <div class="col-md">
                <label class="control-label">\(\lambda\):</label>
            </div>
            <div class="col-md">
                <input id="lambda-slider" type="range" min="0" max="3.4" step="0.01" value="0.0" class="slider">
            </div>
            <div class="col-md">
                <input type="number" id="lambda-input" step="0.01" value="0" style="width: 80px;">
            </div>
            <div class="col-md">
                <label for="maxLambda">\(\lambda_{\text{max}}\):</label>
            </div>
            <div class="col-md">
                <input type="number" id="maxLambda" step="0.01" value="3.4">
            </div>
        </div>
        <div class = "col my-3" align="center">
                <label for="deltaT">\(\Delta t\):</label>
                <input type="number" id="deltaT" value="0.01" step = "0.0001" min="0.0001" style="width: 90px;">
        </div>
        <div class = "col my-3" align="center">
                <label for="maxT">\(t_{\text{final}}\):</label>
                <input type="number" id="maxT" step="0.01" value="10">
        </div>
    </div>
    
    <div class="plot-container" id="plot"></div>
    <div class="col my-3" align="center">
        <label for="yAxisRange">Y-Axis Range:</label>
        <select id="yAxisRange" style="width: 150px;">
            <option value="variable">Variable</option>
            <option value="fixed">Fixed</option>
        </select>
    </div>
    <div class="col my-3" id="fixedRangeInputs" style="display: none;" align="center">
        <label for="yMin">Min:</label>
        <input type="number" id="yMin" step="0.1" value="-3.14" style="width: 80px;">
        <label for="yMax">Max:</label>
        <input type="number" id="yMax" step="0.1" value="9.42" style="width: 80px;">
    </div>
    <div class="col my-3" align="center">
        <label>Graph Options:</label>
        <input type="checkbox" id="showOriginal" checked>
        <label for="showOriginal">Original Horizontal</label>
        <input type="checkbox" id="showSecondOrder" checked>
        <label for="showSecondOrder">Second Order Horizontal</label>
        
        <input type="checkbox" id="showOriginalVertical" checked>
        <label for="showOriginalVertical">Original Vertical</label>
        <input type="checkbox" id="showSecondOrderVertical" checked>
        <label for="showSecondOrderVertical">Second Order Vertical</label>
    </div>
    <div class="col my-3" align="center">
        <label for="themeToggle">Dark Mode:</label>
        <input type="checkbox" id="themeToggle">
    </div>

    <script>
        const sliderA = document.getElementById("A-slider");
        const minInputA = document.getElementById("minA");
        const maxInputA = document.getElementById("maxA");

        minInputA.addEventListener("input", () => {
            sliderA.min = minInputA.value;
            if (parseFloat(sliderA.value) < parseFloat(sliderA.min)) {
                sliderA.value = sliderA.min;
                document.getElementById("A-value").value = sliderA.value;
            }
        });

        maxInputA.addEventListener("input", () => {
            sliderA.max = maxInputA.value;
            if (parseFloat(sliderA.value) > parseFloat(sliderA.max)) {
                sliderA.value = sliderA.max;
                document.getElementById("A-input").value = sliderA.value;
            }
        });

        sliderA.addEventListener("input", () => {
            document.getElementById("A-input").value = sliderA.value;
        });
        
        const sliderOmega = document.getElementById("omega-slider");
        const minInputOmega = document.getElementById("minOmega");
        const maxInputOmega = document.getElementById("maxOmega");

        minInputOmega.addEventListener("input", () => {
            sliderOmega.min = minInputOmega.value;
            if (parseFloat(sliderOmega.value) < parseFloat(sliderOmega.min)) {
                sliderOmega.value = sliderOmega.min;
                document.getElementById("omega-input").textContent = sliderOmega.value;
            }
        });

        maxInputOmega.addEventListener("input", () => {
            sliderOmega.max = maxInputOmega.value;
            if (parseFloat(sliderOmega.value) > parseFloat(sliderOmega.max)) {
                sliderOmega.value = sliderOmega.max;
                document.getElementById("omega-input").textContent = sliderOmega.value;
            }
        });

        sliderOmega.addEventListener("input", () => {
            document.getElementById("omega-input").textContent = sliderOmega.value;
        });
        
        const sliderL = document.getElementById("l-slider");
        const minInputL = document.getElementById("minL");
        const maxInputL = document.getElementById("maxL");

        minInputL.addEventListener("input", () => {
            sliderL.min = minInputL.value;
            if (parseFloat(sliderL.value) < parseFloat(sliderL.min)) {
                sliderL.value = sliderL.min;
                document.getElementById("l-input").textContent = sliderL.value;
            }
        });

        maxInputL.addEventListener("input", () => {
            sliderL.max = maxInputL.value;
            if (parseFloat(sliderL.value) > parseFloat(sliderL.max)) {
                sliderL.value = sliderL.max;
                document.getElementById("l-input").textContent = sliderL.value;
            }
        });

        sliderL.addEventListener("input", () => {
            document.getElementById("l-input").textContent = sliderL.value;
        });
        
        const sliderTheta = document.getElementById("theta-slider");
        const minInputTheta = document.getElementById("minTheta0");
        const maxInputTheta = document.getElementById("maxTheta0");

        minInputTheta.addEventListener("input", () => {
            sliderTheta.min = minInputTheta.value;
            if (parseFloat(sliderTheta.value) < parseFloat(sliderTheta.min)) {
                sliderTheta.value = sliderTheta.min;
                document.getElementById("theta-input").textContent = sliderTheta.value;
            }
        });

        maxInputTheta.addEventListener("input", () => {
            sliderTheta.max = maxInputTheta.value;
            if (parseFloat(sliderTheta.value) > parseFloat(sliderTheta.max)) {
                sliderTheta.value = sliderTheta.max;
                document.getElementById("theta-input").textContent = sliderTheta.value;
            }
        });

        sliderTheta.addEventListener("input", () => {
            document.getElementById("theta-input").textContent = sliderTheta.value;
        });
        
        const sliderLambda = document.getElementById("lambda-slider");
        const minInputLambda = document.getElementById("minLambda");
        const maxInputLambda = document.getElementById("maxLambda");

        minInputLambda.addEventListener("input", () => {
            sliderLambda.min = minInputLambda.value;
            if (parseFloat(sliderLambda.value) < parseFloat(sliderLambda.min)) {
                sliderLambda.value = sliderLambda.min;
                document.getElementById("lambda-input").textContent = sliderLambda.value;
            }
        });

        maxInputLambda.addEventListener("input", () => {
            sliderLambda.max = maxInputLambda.value;
            if (parseFloat(sliderLambda.value) > parseFloat(sliderLambda.max)) {
                sliderLambda.value = sliderLambda.max;
                document.getElementById("lambda-input").textContent = sliderLambda.value;
            }
        });

        sliderLambda.addEventListener("input", () => {
            document.getElementById("lambda-input").textContent = sliderLambda.value;
        });
        
        // Differential equation: θ''(t) + (g/l) * sin(θ) = A * ω² * cos(ωt) * cos(θ)
        const g = 9.8; // gravitational acceleration

        // Numerical solver (Runge-Kutta 4th order method)
        function rungeKutta(h, t0, tf, y0, f) {
            let t = t0;
            let y = y0;
            const steps = Math.floor((tf - t0) / h);
            const tValues = [t];
            const yValues = [y.slice()];

            for (let i = 0; i < steps; i++) {
                const k1 = f(t, y);
                const k2 = f(t + h / 2, y.map((v, idx) => v + h / 2 * k1[idx]));
                const k3 = f(t + h / 2, y.map((v, idx) => v + h / 2 * k2[idx]));
                const k4 = f(t + h, y.map((v, idx) => v + h * k3[idx]));
                
                for (let j = 0; j < y.length; j++) {
                    y[j] += h / 6 * (k1[j] + 2 * k2[j] + 2 * k3[j] + k4[j]);
                }

                t += h;
                tValues.push(t);
                yValues.push(y.slice());
            }

            return { t: tValues, y: yValues };
        }

        // System of ODEs: [θ, θ']
        function pendulumODE(t, y, A, omega, l, lambda) {
            const theta = y[0];
            const thetaDot = y[1];
            const thetaDDot = -(g / l) * Math.sin(theta) + (A * omega**2 / l) * Math.cos(omega * t) * Math.cos(theta) - lambda * thetaDot;
            return [thetaDot, thetaDDot];
        }
        
        function pendulumODESecondOrder(t, y, A, omega, l, lambda) {
            const theta = y[0];
            const thetaDot = y[1];

            // Second-order approximation
            const thetaDDot = -(g / l) * ((Math.PI - theta) + Math.pow((theta - Math.PI), 3) / 6)
                              + (A * omega**2 / l) * (-1 + Math.pow((theta - Math.PI), 2) / 2) * Math.cos(omega * t) - lambda * thetaDot;

            return [thetaDot, thetaDDot];
        }
        
        function pendulumODE_vertical(t, y, A, omega, l, lambda) {
            const theta = y[0];
            const thetaDot = y[1];
            const thetaDDot = -(g / l) * Math.sin(theta) - (A * omega**2 / l) * Math.cos(omega * t) * Math.sin(theta) - lambda * thetaDot;
            return [thetaDot, thetaDDot];
        }
        
        function pendulumODESecondOrder_vertical(t, y, A, omega, l, lambda) {
            const theta = y[0];
            const thetaDot = y[1];

            // Second-order approximation
            const thetaDDot = -(g / l) * ((Math.PI - theta) + Math.pow((theta - Math.PI), 3) / 6)
                              - (A * omega**2 / l) * ((Math.PI - theta) + Math.pow((theta - Math.PI), 3) / 6) * Math.cos(omega * t) - lambda * thetaDot;

            return [thetaDot, thetaDDot];
        }

        // Plotting function
        function plotResults(t, y, secondOrderY, y_vert, secondOrderY_vert) {
            const yAxisRangeOption = document.getElementById("yAxisRange").value;
            const yMin = parseFloat(document.getElementById("yMin").value);
            const yMax = parseFloat(document.getElementById("yMax").value);

            const showOriginal = document.getElementById("showOriginal").checked;
            const showSecondOrder = document.getElementById("showSecondOrder").checked;
            const showOriginalVertical = document.getElementById("showOriginalVertical").checked;
            const showSecondOrderVertical = document.getElementById("showSecondOrderVertical").checked;

            let traces = [];
            
            if (showOriginal)
            {
                traces.push({
                    x: t,
                    y: y.map(yi => yi[0]),  // θ(t) as function of time for the original system
                    type: 'scatter',
                    mode: 'lines',
                    name: '$\\text{Original Horizontal}$',
                    line: { color: 'blue' }
                });
            }
            
            if (showSecondOrder)
            {
                traces.push({
                    x: t,
                    y: secondOrderY.map(yi => yi[0]),  // θ(t) as function of time for the second-order approximation
                    type: 'scatter',
                    mode: 'lines',
                    name: '$\\text{Second-Order Horizontal}$',
                    line: { color: 'green' }
                });
            }
            
            if (showOriginalVertical)
            {
                traces.push({
                    x: t,
                    y: y_vert.map(yi => yi[0]),  // θ(t) as function of time for the original system
                    type: 'scatter',
                    mode: 'lines',
                    name: '$\\text{Original Vertical}$',
                    line: { color: 'orange' }
                });
            }
            
            if (showSecondOrderVertical)
            {
                traces.push({
                    x: t,
                    y: secondOrderY_vert.map(yi => yi[0]),  // θ(t) as function of time for the second-order approximation
                    type: 'scatter',
                    mode: 'lines',
                    name: '$\\text{Second-Order Vertical}$',
                    line: { color: 'magenta' }
                });
            }

            const layout = {
                title: '$\\text{Inverted Pendulum: }\\theta(t)$',
                xaxis: { title: '$\\text{Time (s)}$' },
                yaxis: {title: '$\\theta(t)\\text{ (radians)}$', range: yAxisRangeOption === "fixed" ? [yMin, yMax] : undefined},
                plot_bgcolor: getComputedStyle(document.documentElement).getPropertyValue('--plot-bg-color'),
                paper_bgcolor: getComputedStyle(document.documentElement).getPropertyValue('--background-color'),
                font: { color: getComputedStyle(document.documentElement).getPropertyValue('--text-color') },
                showlegend: true
            };

            // Plot both traces
            Plotly.newPlot('plot', traces, layout);
            
            window.addEventListener('resize', () => {
                Plotly.Plots.resize('plot');
            });
        }


        // Update plot based on current parameters
        function updatePlot() {
            const A = parseFloat(document.getElementById('A-slider').value);
            const omega = parseFloat(document.getElementById('omega-slider').value);
            const l = parseFloat(document.getElementById('l-slider').value);
            const theta0 = parseFloat(document.getElementById('theta-slider').value);
            const lambda = parseFloat(document.getElementById('lambda-slider').value);
            
            const h_min = parseFloat(document.getElementById('deltaT').min);
            let h_temp_str = document.getElementById('deltaT').value;
            let h_temp = (!h_temp_str) ? 0.01 : parseFloat(document.getElementById('deltaT').value);
            const h = (h_temp > h_min) ? h_temp : h_min; // Time step
            const t0 = 0;  // Start time
            const tf = parseFloat(document.getElementById('maxT').value); // End time

            // Update the displayed values for sliders
            document.getElementById('A-input').textContent = A;
            document.getElementById('omega-input').textContent = omega;
            document.getElementById('l-input').textContent = l;
            document.getElementById('theta-input').textContent = theta0;
            document.getElementById('lambda-input').textContent = lambda;
            
            document.getElementById('deltaT').value = h;
            
            // Initial conditions and solver parameters
            
            let y0 = [theta0, 0];  // Initial conditions [θ₀, θ'₀]
            // Solve the system of ODEs
            const result = rungeKutta(h, t0, tf, y0, (t, y) => pendulumODE(t, y, A, omega, l, lambda));
            y0 = [theta0, 0];  // Initial conditions [θ₀, θ'₀]
            const secondOrderResult = rungeKutta(h, t0, tf, y0, (t, y) => pendulumODESecondOrder(t, y, A, omega, l, lambda));
            y0 = [theta0, 0];  // Initial conditions [θ₀, θ'₀]
            const result_vertical = rungeKutta(h, t0, tf, y0, (t, y) => pendulumODE_vertical(t, y, A, omega, l, lambda));
            y0 = [theta0, 0];  // Initial conditions [θ₀, θ'₀]
            const secondOrderResult_vertical = rungeKutta(h, t0, tf, y0, (t, y) => pendulumODESecondOrder_vertical(t, y, A, omega, l, lambda));
            
            // Plot the results
            plotResults(result.t, result.y, secondOrderResult.y, result_vertical.y, secondOrderResult_vertical.y);
            
        }
        
        function syncSliderWithInput(sliderId, inputId, minInputId, maxInputId) {
            const slider = document.getElementById(sliderId);
            const input = document.getElementById(inputId);
            const minInput = document.getElementById(minInputId);
            const maxInput = document.getElementById(maxInputId);

            // Synchronize slider to input
            slider.addEventListener("input", () => {
                input.value = slider.value;
                updatePlot();
            });

            // Synchronize input to slider, with delayed validation
            input.addEventListener("input", () => {
                const rawValue = input.value;

                // Allow empty or intermediate input (e.g., "3.")
                if (rawValue === "" || rawValue.endsWith(".")) {
                    return;
                }

                // Parse the input value
                const value = parseFloat(rawValue);

                // If valid, update the slider
                if (!isNaN(value)) {
                    slider.value = value;
                    updatePlot();
                }
            });

            // Validate the input and constrain it to min/max on blur
            input.addEventListener("blur", () => {
                let value = parseFloat(input.value);
                const minValue = parseFloat(minInput.value);
                const maxValue = parseFloat(maxInput.value);

                // Constrain to min/max if the value is valid
                if (!isNaN(value)) {
                    if (value < minValue) {
                        value = minValue;
                    } else if (value > maxValue) {
                        value = maxValue;
                    }
                    input.value = value;
                    slider.value = value;
                } else {
                    // If invalid, reset to the slider's current value
                    input.value = slider.value;
                }

                updatePlot();
            });

            // Update slider bounds based on min/max inputs
            minInput.addEventListener("input", () => {
                slider.min = minInput.value;
                const minValue = parseFloat(minInput.value);
                if (parseFloat(slider.value) < minValue) {
                    slider.value = minValue;
                    input.value = minValue;
                    updatePlot();
                }
            });

            maxInput.addEventListener("input", () => {
                slider.max = maxInput.value;
                const maxValue = parseFloat(maxInput.value);
                if (parseFloat(slider.value) > maxValue) {
                    slider.value = maxValue;
                    input.value = maxValue;
                    updatePlot();
                }
            });
        }
        
        document.getElementById('themeToggle').addEventListener('change', (event) => {
            const isDarkMode = event.target.checked;

            if (isDarkMode) {
                // Apply dark mode styles
                document.documentElement.style.setProperty('--background-color', '#1e1e1e');
                document.documentElement.style.setProperty('--text-color', '#ffffff');
                document.documentElement.style.setProperty('--plot-bg-color', '#1e1e1e');
                document.documentElement.style.setProperty('--plot-grid-color', '#555555');
            } else {
                // Revert to light mode styles
                document.documentElement.style.setProperty('--background-color', '#ffffff');
                document.documentElement.style.setProperty('--text-color', '#333333');
                document.documentElement.style.setProperty('--plot-bg-color', '#ffffff');
                document.documentElement.style.setProperty('--plot-grid-color', '#dddddd');
            }

            updatePlot(); // Update the Plotly plot to apply the new theme
        });

        // Initialize synchronization for each parameter
        syncSliderWithInput("A-slider", "A-input", "minA", "maxA");
        syncSliderWithInput("omega-slider", "omega-input", "minOmega", "maxOmega");
        syncSliderWithInput("l-slider", "l-input", "minL", "maxL");
        syncSliderWithInput("theta-slider", "theta-input", "minTheta0", "maxTheta0");
        syncSliderWithInput("lambda-slider", "lambda-input", "minLambda", "maxLambda");

        // Event listeners for sliders
        document.getElementById('A-slider').addEventListener('input', updatePlot);
        document.getElementById('omega-slider').addEventListener('input', updatePlot);
        document.getElementById('l-slider').addEventListener('input', updatePlot);
        document.getElementById('theta-slider').addEventListener('input', updatePlot);
        document.getElementById('lambda-slider').addEventListener('input', updatePlot);
        document.getElementById('maxT').addEventListener('input', updatePlot);
        document.getElementById('deltaT').addEventListener('input', updatePlot);
        // Show or hide the custom range inputs based on the dropdown selection
        document.getElementById('yAxisRange').addEventListener('change', () => {
            const yAxisRangeOption = document.getElementById('yAxisRange').value;
            const fixedRangeInputs = document.getElementById('fixedRangeInputs');
            fixedRangeInputs.style.display = yAxisRangeOption === "fixed" ? "block" : "none";
            updatePlot();
        });

        // Event listeners for custom range inputs
        document.getElementById('yMin').addEventListener('input', updatePlot);
        document.getElementById('yMax').addEventListener('input', updatePlot);
        // Event listeners for checkboxes
        document.getElementById('showOriginal').addEventListener('change', updatePlot);
        document.getElementById('showSecondOrder').addEventListener('change', updatePlot);
        document.getElementById('showOriginalVertical').addEventListener('change', updatePlot);
        document.getElementById('showSecondOrderVertical').addEventListener('change', updatePlot);


        // Initial plot
        updatePlot();
    </script>
</body>
</html>


<!--TODO: Add damping, vertical vs horizontal, check papers for horizontal vs vertical -->
